<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">CNode：Node.js专业中文社区</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" name="renderer" content="webkit"><meta data-n-head="true" data-hid="keywords" name="keywords" content="vue, nuxt, nuxt2, nodejs, node, express, connect, socket.io"><meta data-n-head="true" data-hid="author" name="author" content="ly2011"><meta data-n-head="true" data-hid="description" name="description" content="CNode：Node.js专业中文社区"><link data-n-head="true" rel="icon" type="image/x-icon" href="/favicon.ico"><base href="/nuxt-blog/"><link rel="preload" href="/nuxt-blog/_nuxt/77a49a90f4c6b7205154.js" as="script"><link rel="preload" href="/nuxt-blog/_nuxt/47daf545fd64040ca35e.js" as="script"><link rel="preload" href="/nuxt-blog/_nuxt/928ab6f72fb877e28078.css" as="style"><link rel="preload" href="/nuxt-blog/_nuxt/17ceb88e98e01c7e5425.js" as="script"><link rel="preload" href="/nuxt-blog/_nuxt/2c0df2ca181a5c7413d1.css" as="style"><link rel="preload" href="/nuxt-blog/_nuxt/6081eb96f6d7595dbdc5.js" as="script"><link rel="preload" href="/nuxt-blog/_nuxt/09a0a89ec7b517d451d0.css" as="style"><link rel="preload" href="/nuxt-blog/_nuxt/865c83433feab54c1410.js" as="script"><link rel="stylesheet" href="/nuxt-blog/_nuxt/928ab6f72fb877e28078.css"><link rel="stylesheet" href="/nuxt-blog/_nuxt/2c0df2ca181a5c7413d1.css"><link rel="stylesheet" href="/nuxt-blog/_nuxt/09a0a89ec7b517d451d0.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="navbar" data-v-2e7f6bee><div class="navbar-inner" data-v-2e7f6bee><div class="navbar-container" data-v-2e7f6bee><div class="logo" data-v-2e7f6bee><a href="javascript:;" class="brand" data-v-2e7f6bee><img src="/nuxt-blog/_nuxt/img/86f6a7c.svg" alt="cnodejs" data-v-2e7f6bee></a> <form class="el-form" data-v-2e7f6bee><div class="el-input el-input--mini el-input--prefix" data-v-2e7f6bee><!----><input autocomplete="off" placeholder="请输入内容" class="el-input__inner"><span class="el-input__prefix"><i class="el-input__icon el-icon-search"></i></span><!----><!----></div></form>>
      </div> <ul class="nav" data-v-2e7f6bee><li data-v-2e7f6bee><a href="/nuxt-blog/" class="nuxt-link-exact-active nuxt-link-active" data-v-2e7f6bee>
              首页
            </a></li><!----><li data-v-2e7f6bee><a href="/nuxt-blog/" class="nuxt-link-exact-active nuxt-link-active" data-v-2e7f6bee>
              新手入门
            </a></li><li data-v-2e7f6bee><a href="/nuxt-blog/" class="nuxt-link-exact-active nuxt-link-active" data-v-2e7f6bee>
              API
            </a></li><li data-v-2e7f6bee><a href="/nuxt-blog/" class="nuxt-link-exact-active nuxt-link-active" data-v-2e7f6bee>
              关于
            </a></li><li data-v-2e7f6bee><a href="/nuxt-blog/" class="nuxt-link-exact-active nuxt-link-active" data-v-2e7f6bee>
              设置
            </a></li><li data-v-2e7f6bee><a href="/nuxt-blog/register" data-v-2e7f6bee>
              注册
            </a></li><li data-v-2e7f6bee><a href="/nuxt-blog/login" data-v-2e7f6bee>
              登录
            </a></li><!----></ul></div></div></div> <section class="topics-container container" data-v-a6f94d06><div id="main" data-v-a6f94d06><aside id="sidebar" data-v-3efee4d3 data-v-a6f94d06><div class="el-card box-card is-never-shadow" data-v-3efee4d3><div class="el-card__header"><div class="box-card-header" data-v-3efee4d3><span data-v-3efee4d3>CNode：Node.js专业中文社区</span></div></div><div class="el-card__body"> <div class="box-card-content login-box" data-v-3efee4d3><div class="box-card-content-header" data-v-3efee4d3>
        您可以
        <a href="/nuxt-blog/login" data-v-3efee4d3>
          登录
        </a>
        或
        <a href="/nuxt-blog/register" data-v-3efee4d3>
          注册
        </a>，也可以
        <button type="button" class="el-button el-button--primary" data-v-3efee4d3><!----><!----><span>通过 GitHub 登录</span></button></div></div></div></div> <!----> <!----> <!----> <!----></aside> <div id="content" data-v-a6f94d06><header class="header" data-v-a6f94d06><div class="el-tabs el-tabs--top" data-v-a6f94d06><div class="el-tabs__header is-top"><div class="el-tabs__nav-wrap is-top"><div class="el-tabs__nav-scroll"><div role="tablist" class="el-tabs__nav is-top" style="transform:translateX(0)"><div class="el-tabs__active-bar is-top"></div></div></div></div></div><div class="el-tabs__content"><div role="tabpanel" aria-hidden="true" id="pane-null" aria-labelledby="tab-null" class="el-tab-pane" style="display:none" data-v-a6f94d06></div><div role="tabpanel" aria-hidden="true" id="pane-good" aria-labelledby="tab-good" class="el-tab-pane" style="display:none" data-v-a6f94d06></div><div role="tabpanel" aria-hidden="true" id="pane-share" aria-labelledby="tab-share" class="el-tab-pane" style="display:none" data-v-a6f94d06></div><div role="tabpanel" aria-hidden="true" id="pane-ask" aria-labelledby="tab-ask" class="el-tab-pane" style="display:none" data-v-a6f94d06></div><div role="tabpanel" aria-hidden="true" id="pane-job" aria-labelledby="tab-job" class="el-tab-pane" style="display:none" data-v-a6f94d06></div><div role="tabpanel" aria-hidden="true" id="pane-dev" aria-labelledby="tab-dev" class="el-tab-pane" style="display:none" data-v-a6f94d06></div></div></div></header> <div class="table-list" data-v-a6f94d06><div class="topic_list" data-v-cba81d8e data-v-a6f94d06><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars0.githubusercontent.com/u/376338?v=4&s=120" title="meikidd" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        317
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        7820
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>5小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag top" data-v-cba81d8e>置顶</span> <a href="javascript:;" title="送几本《Node.js开发实战》" class="topic_title" data-v-cba81d8e>
        送几本《Node.js开发实战》
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars1.githubusercontent.com/u/1147375?v=4&s=120" title="alsotang" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        122
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        13677
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>6小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag top" data-v-cba81d8e>置顶</span> <a href="javascript:;" title="服务器迁移至 aws 日本机房" class="topic_title" data-v-cba81d8e>
        服务器迁移至 aws 日本机房
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars3.githubusercontent.com/u/3118295?v=4&s=120" title="i5ting" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        46
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        6504
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>15天前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag top" data-v-cba81d8e>置顶</span> <a href="javascript:;" title="【活动+视频】北京1月12日Node Party活动" class="topic_title" data-v-cba81d8e>
        【活动+视频】北京1月12日Node Party活动
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars3.githubusercontent.com/u/24958677?v=4&s=120" title="BengBu-YueZhang" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        3
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        730
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>1小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag share" data-v-cba81d8e>分享</span> <a href="javascript:;" title="最近学习canvas，做了一些效果的合集" class="topic_title" data-v-cba81d8e>
        最近学习canvas，做了一些效果的合集
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars0.githubusercontent.com/u/1525931?v=4&s=120" title="houxiaohou" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        0
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        50
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>2小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag share" data-v-cba81d8e>分享</span> <a href="javascript:;" title="我们开发了一个在线图片压缩、PDF 压缩、合并、分割的小工具" class="topic_title" data-v-cba81d8e>
        我们开发了一个在线图片压缩、PDF 压缩、合并、分割的小工具
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars2.githubusercontent.com/u/26496557?v=4&s=120" title="Fundebug" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        3
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        273
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>3小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag share" data-v-cba81d8e>分享</span> <a href="javascript:;" title="搞懂 JavaScript 继承原理" class="topic_title" data-v-cba81d8e>
        搞懂 JavaScript 继承原理
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars1.githubusercontent.com/u/6891001?v=4&s=120" title="yunfei" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        4
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        521
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>4小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag share" data-v-cba81d8e>分享</span> <a href="javascript:;" title="圣诞桌面 Merry Christmas" class="topic_title" data-v-cba81d8e>
        圣诞桌面 Merry Christmas
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars3.githubusercontent.com/u/1480587?v=4&s=120" title="iori2882" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        5
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        259
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>4小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag ask" data-v-cba81d8e>问答</span> <a href="javascript:;" title="请教:输入汉字拼音首字母,模糊查询数据" class="topic_title" data-v-cba81d8e>
        请教:输入汉字拼音首字母,模糊查询数据
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars0.githubusercontent.com/u/24504661?v=4&s=120" title="hejiaoshou" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        3
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        545
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>4小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag ask" data-v-cba81d8e>问答</span> <a href="javascript:;" title="webpack4多页面多项目工程的公共js提取问题" class="topic_title" data-v-cba81d8e>
        webpack4多页面多项目工程的公共js提取问题
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars0.githubusercontent.com/u/25942898?v=4&s=120" title="witlxx" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        0
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        82
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>5小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag ask" data-v-cba81d8e>问答</span> <a href="javascript:;" title="node的第三方模块中支持mysql schema的模块吗？" class="topic_title" data-v-cba81d8e>
        node的第三方模块中支持mysql schema的模块吗？
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars2.githubusercontent.com/u/7995232?v=4&s=120" title="JZLeung" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        30
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        1277
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>6小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag ask" data-v-cba81d8e>问答</span> <a href="javascript:;" title="Egg.js/thinkjs/nestjs 该如何选择？" class="topic_title" data-v-cba81d8e>
        Egg.js/thinkjs/nestjs 该如何选择？
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars1.githubusercontent.com/u/15104950?v=4&s=120" title="JarvisQJ" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        5
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        739
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>6小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag ask" data-v-cba81d8e>问答</span> <a href="javascript:;" title="《JavaScript高级程序设计》中的一个疑点" class="topic_title" data-v-cba81d8e>
        《JavaScript高级程序设计》中的一个疑点
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars2.githubusercontent.com/u/8817810?v=4&s=120" title="kalengo" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        0
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        112
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>7小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag share" data-v-cba81d8e>分享</span> <a href="javascript:;" title="AI考拉技术分享-Node基础架构专题（三）" class="topic_title" data-v-cba81d8e>
        AI考拉技术分享-Node基础架构专题（三）
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars2.githubusercontent.com/u/26496557?v=4&s=120" title="Fundebug" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        0
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        253
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>10小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag share" data-v-cba81d8e>分享</span> <a href="javascript:;" title="我从来不理解JavaScript闭包，直到有人这样向我解释它..." class="topic_title" data-v-cba81d8e>
        我从来不理解JavaScript闭包，直到有人这样向我解释它...
      </a></div></div><div class="cell" data-v-cba81d8e><a href="javascript:;" class="user_avatar pull-left" data-v-cba81d8e><img src="https://avatars0.githubusercontent.com/u/3991376?v=4&s=120" title="hhffhh" data-v-cba81d8e></a> <span class="reply_count pull-left" data-v-cba81d8e><span title="回复数" class="count_of_replies" data-v-cba81d8e>
        14
      </span> <span class="count_seperator" data-v-cba81d8e>/</span> <span title="点击数" class="count_of_visits" data-v-cba81d8e>
        1293
      </span></span> <a href="javascript:;" class="last_time pull-right" data-v-cba81d8e><span class="last_active_time" data-v-cba81d8e>10小时前</span></a> <div class="topic_title_wrapper" data-v-cba81d8e><span class="tag ask" data-v-cba81d8e>问答</span> <a href="javascript:;" title="如何学习angular" class="topic_title" data-v-cba81d8e>
        如何学习angular
      </a></div></div></div> <div class="pagination" data-v-a6f94d06><div class="el-pagination" data-v-a6f94d06><span class="el-pagination__total">共 1000 条</span><button type="button" disabled class="btn-prev"><i class="el-icon el-icon-arrow-left"></i></button><ul class="el-pager"><li class="number active">1</li><!----><li class="number">2</li><li class="number">3</li><li class="number">4</li><li class="number">5</li><li class="number">6</li><li class="el-icon more btn-quicknext el-icon-more"></li><li class="number">67</li></ul><button type="button" class="btn-next"><i class="el-icon el-icon-arrow-right"></i></button><span class="el-pagination__jump">前往<div class="el-input el-pagination__editor is-in-pagination"><!----><input type="number" autocomplete="off" min="1" max="67" value="1" class="el-input__inner"><!----><!----><!----></div>页</span><button type="button" class="el-button jump-page-btn el-button--primary el-button--small" data-v-a6f94d06><!----><!----><span>
              跳转
            </span></button></div></div></div></div></div></section> <footer class="footer" data-v-3df5051d><div class="footer_main" data-v-3df5051d><div class="links" data-v-3df5051d><a href="javascript:;" class="dark" data-v-3df5051d>RSS</a> <a href="https://github.com/ly2011/nuxt-blog" class="dark" data-v-3df5051d>源码地址</a></div> <div class="col_fade" data-v-3df5051d><p data-v-3df5051d>CNode 社区为国内最专业的 Node.js 开源技术社区，致力于 Node.js 的技术研究。</p> <p data-v-3df5051d>服务器赞助商为
        <a href="http://www.ucloud.cn/?utm_source=zanzhu&utm_campaign=cnodejs&utm_medium=display&utm_content=yejiao&ytag=cnodejs_logo" target="_blank" data-label="ucloud_bottom" class="sponsor_outlink" data-v-3df5051d><img src="//static.cnodejs.org/FuIpEaM9bvsZKnQ3QfPtBHWQmLM9" title="ucloud" alt="ucloud" width="92px" data-v-3df5051d></a>
        ，存储赞助商为
        <a href="http://www.qiniu.com/?ref=cnode" target="_blank" data-label="qiniu_bottom" class="sponsor_outlink" data-v-3df5051d><img src="//static.cnodejs.org/Fg0jtDIcTqVC049oVu5-sn6Om4NX" title="七牛云存储" alt="七牛云存储" width="115px" data-v-3df5051d></a>
        ，由<a href="https://www.aliyun.com/product/nodejs?ref=cnode" target="_blank" data-label="alinode_bottom" class="sponsor_outlink" data-v-3df5051d><img src="//static.cnodejs.org/FpMZk31PDyxkC8yStmMQL4XroaGD" title="alinode" alt="alinode" height="54px" width="166px" data-v-3df5051d></a>提供应用性能服务。
      </p> <p data-v-3df5051d>新手搭建 Node.js 服务器，推荐使用无需备案的 <a href="https://www.digitalocean.com/?refcode=eba02656eeb3" data-v-3df5051d>DigitalOcean(https://www.digitalocean.com/)</a></p></div></div></footer> <div class="back-to-ceiling" style="width:24px;top:75px;right:0;display:none" data-v-3563b449 data-v-3563b449>
    回到顶部
    </div></div></div></div><script>window.__NUXT__=function(n,r,t,e,o,a,c,i,s,u,d,p,l,h){return{layout:"default",data:[{}],error:null,state:{topic:{topic:{},loading:n},topics:{topics:[{id:"5c2edce13898674067a7b103",author_id:"5372465f3c72496d41009adc",tab:r,content:"截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\r\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\r\n请评论区留下联系方式。\r\n![image.png](//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej)\r\n\r\n---------------- 以下是原文 ----------------\r\n\r\n新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。\r\n\r\n赠书办法：\r\n* 只须在本贴留言即可。\r\n* 从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。\r\n* 获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。\r\n* 截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。\r\n* 由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。\r\n* 开奖后 72 小时未能回复联系方式者视为放弃。\r\n\r\n试读样章：[https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg](https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg)\r\n京东有售：[https://item.jd.com/12460185.html](https://item.jd.com/12460185.html)\r\n![WechatIMG148 copy.jpg](//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh)",title:"送几本《Node.js开发实战》",last_reply_at:"2019-02-12T08:25:08.118Z",good:n,top:!0,reply_count:317,visit_count:7820,create_at:"2019-01-04",author:{loginname:"meikidd",avatar_url:"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{id:"5bd4772a14e994202cd5bdb7",author_id:"504c28a2e2b845157708cb61",tab:r,content:"2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 @i5ting 帮忙看看，结果登不上也ping不通。\r\n后来收到短信，发现是被ucloud封了，短信内容如下：\r\n\r\n> 【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：https://cnodejs.org/topic/57239bce5a26c4a841ecbf01 （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]\r\n\r\n然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\r\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。\r\n\r\n我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。\r\n\r\n建议翻墙访问。",title:"服务器迁移至 aws 日本机房",last_reply_at:"2019-02-12T07:24:19.605Z",good:n,top:!0,reply_count:122,visit_count:13677,create_at:"2018-10-27",author:{loginname:"alsotang",avatar_url:"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{id:"5c1760337ec239239ff579a2",author_id:"54009f5ccd66f2eb37190485",tab:r,content:"北京1月12日Node Party活动视频地址：https://edu.talkingdata.com/open-class\r\n\r\n\r\nNode Party 是社区发起的一个面向 Node.js 和大前端爱好者的非商业，社区驱动的技术分享聚会，希望能够构建一个持续的分享学习平台，一起发展大前端生态。\r\n\r\n北京1月12日Node Party线下活动（周六）下午2点到6点，将近100人\r\n\r\n- 主题分享（已确认，共5个主题：3个Node.js主题，一个运维，一个前端）\r\n\t- 《重新认识Nodejs后端开发》 eggjs + React + SSR 做同构直出（去哪儿）\r\n\t- 《用mqtt协议实现nodejs长连接服务》Nodejs长连接，主要是性能和协议改造方面的（新浪）\r\n\t- 《浅谈nodejs异步那点事》（360）\r\n\t- 结合Node.js讲一下Docker 实践和原理（网易）\r\n\t- iview作者：如何做好一个开源项目（TalkingData）\r\n- 视情况可以考虑晚上AA聚\r\n\r\n时间：北京1月12日（周六）下午2点到6点\r\n地点：东直门TalkingData赞助的502教室\r\n人数：最多100人\r\n直播地址：https://live.bilibili.com/1353202\r\n\r\n现场还有 @justjavac，@小爵，@快手天翔 @王龑 等大咖。\r\n\r\n图灵出版社赞助了20本书，现场送给大家\r\n\r\n## 日程安排\r\n\r\n每个主题分享+答疑共45分钟，5个主题分享：3个Node.js主题，一个运维，一个前端\r\n茶歇5分钟（北京乐至道科技有限公司赞助茶歇，已经京东到会场）\r\n圆桌会议30分钟\r\n\r\n2:00-2:45\r\n刘露颖：《用mqtt协议实现nodejs长连接服务》Nodejs长连接，主要是性能和协议改造方面的（新浪）\r\n\r\n2:45-3:30\r\n张晋涛：《结合Node.js讲一下Docker 实践和原理》（网易）\r\n\r\n3:30-4:15\r\niView作者Aresn：如何做好一个开源项目（TalkingData）\r\n\r\n茶歇5分钟，感谢北京乐至道科技有限公司。DaDEX.io基于EOS公链开发，链上合约自动执行，全部交易上链，率先实现去中心化交易、高并发、低手续费、资金安全、最高交易透明的真去中心化交易所范式，无需注册、认证等繁琐流程，个人钱包内一键交易。致力于完善EOS生态，服务EOS用户，与跨链技术的结合，向传统中心化交易所发起挑战\r\n\r\n4:20-4:50\r\n圆桌会议：畅想一下前端2019（大神待定）\r\n\r\n4:50-5:35\r\n兴百放：《重新认识Nodejs后端开发》 eggjs + React + SSR 做同构直出（去哪儿）\r\n\r\n5:35-6:10\r\n宋光宇：《浅谈nodejs异步那点事》（360）\r\n\r\n\r\n## 主题\r\n\r\n###  1）《重新认识Node.js后端开发》\r\n\r\n兴百放，先就职在美团外卖事业部，负责前后端分离，以及 Nodejs 推广工作。本着不管黑猫白猫，只要能解决现实业务问题，提高团队工作效率，就是好猫的原则，致力于让团队成员从重复，耗时，繁琐的一些工作中解放出来。\r\n\r\n随着前端行业的蓬勃发展，越来越多的技术团队，对前端的职责范围，也慢慢的延伸到后端。这里就分享一些在我们进行服务自治（BFF），以及接管传统后端职责一些沉淀和经验。内容主要包括如何做技术框架的选型，使用 egg 一些经验总结，和 eggjs + React + SSR 做同构直出等内容 。\r\n\r\n![兴百放.png](//static.cnodejs.org/FnS8WR95lO1Ff7KevyeHsDHuNCjp)\r\n\r\n### 2）《Docker 实践和原理》\r\n\r\n张晋涛，目前任网易有道资深运维开发工程师, 负责 DevOPS 实践落地及 Kubernetes 容器化平台及自动化平台的规划建设等。骨灰级 Linux/Vim 玩家，对 Docker， Kubernetes 及相关生态有大量实践及深入源码的研究。曾负责美图运维自动化平台体系建设。掘金小册《Kubernetes 从上手到实践》作者。\r\n\r\n随着 Kubernetes 等云原生技术的事实标准已经形成，容器化技术作为其重要的组成部分也被使用的越来越广泛。在我们的开发实践中，如何更好的利用容器化技术( Docker )来提升我们的开发，测试效率也是我们所关注的重点。 本次分享集中于如何用 Docker 提升我们的效率以及如何用好它。以 node 和 前端为入手点，希望能对大家有所帮助。\r\n\r\n![张晋涛.png](//static.cnodejs.org/FoVKIjHzQJqhwe6IgBWiw2BEWoX-)\r\n\r\n### 3）《浅谈Node.js异步那点事》\r\n\r\n宋光宇 360前端工程师 360视频云/360云盘@奇舞团，\r\n\r\nnodejs给前端赋予了更多的生命力，它的异步模型给他带来无限的潜力。\r\n今天通过libuv这个nodejs核心库来聊聊nodejs异步的那点事。\r\n\r\n![宋光宇.png](//static.cnodejs.org/FmlpCMQIdEjJBXaxDSLS77gpcdqw)\r\n\r\n### 4）iView作者：如何做好一个开源项目\r\n\r\nAresn，基于 Vue.js 的开源 UI 组件库 — iView 的作者。现担任大数据公司 TalkingData 前端架构师。著有《Vue.js实战》、《Vue.js组件精讲》。\r\nTopic：\r\n\r\n- iView 的故事\r\n- 第一批用户\r\n- 持续运营\r\n- 国际化\r\n- 让更多的人参与\r\n- 让 Robot 来做“坏人”\r\n- 赞助与商业化\r\n\r\n![梁灏.png](//static.cnodejs.org/FlPAOO-2v0z85GbQ5StQPcIo5ESN)\r\n\r\n### 5）《用mqtt协议实现Node.js长连接服务》\r\n\r\n刘露颖，曾就职搜狐视频，新浪博客，目前任职新浪移动团队资深前端开发工程师，负责nodejs相关的服务开发与维护、以及部分运维相关工作。致力于v8的研究，对c++与nodejs之间的关系有深厚兴趣，并付诸实践。\r\n\r\nmqtt协议随着各种手机app的普及，在移动互联网中有了广泛的应用，借着项目的实践过程，讲术如何更好的使mqtt与nodejs相结合，为现在越来越普遍的高并发场景提供长连接服务的解决方案。\r\n\r\n![刘露颖.png](//static.cnodejs.org/FtVeXBznM2mqBtcxdDQEiC13R_xj)\r\n\r\n## 微信群\r\n\r\n群满100人后无法加群的, 添加我微信 mcdongWang 备注 node party 北京 我回拉你进群\r\n\r\n![31545188678_.pic.jpg](//static.cnodejs.org/FvqZCML0PfbFHt6xknAhJmkWKDPU)\r\n\r\n\r\n公众号文章地址\r\n\r\nhttps://mp.weixin.qq.com/s?__biz=MzAxMTU0NTc4Nw==&mid=2661157727&idx=1&sn=0b7a6aa495fbe3afe4a4d3774faf8706&chksm=80d5d68bb7a25f9d125e17ff08d1f373435db4a8a7fe2d074f4fbe58c517beb93266e08a4295&token=1373872492&lang=zh_CN#rd",title:"【\b活动+视频】北京1月12日Node Party活动",last_reply_at:"2019-01-28T04:35:22.027Z",good:n,top:!0,reply_count:46,visit_count:6504,create_at:"2018-12-17",author:{loginname:"i5ting",avatar_url:"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{id:"5c57980805cc322e7b1373ab",author_id:"5ac77987e34737560fccaa7b",tab:r,content:"- [爱心闪烁效果](http://canvas.bengbuzhangyue.xyz/love/dist/)\r\n- [简单的离子效果](http://canvas.bengbuzhangyue.xyz/ballline/dist/)\r\n- [简单的烟花效果](http://canvas.bengbuzhangyue.xyz/simple_fireworks/dist/)\r\n- [canvas实现图片裁切](http://canvas.bengbuzhangyue.xyz/simple_image_edit/dist/)\r\n- [canvas射激光](http://canvas.bengbuzhangyue.xyz/BiuBiuBiu/dist/)\r\n- [canvas实现鼠标跟踪动画](http://canvas.bengbuzhangyue.xyz/paopao/dist/)\r\n- [canvas实现3D文字](http://canvas.bengbuzhangyue.xyz/3d/dist/)",title:"最近学习canvas，做了一些效果的合集",last_reply_at:"2019-02-12T12:09:29.478Z",good:n,top:n,reply_count:3,visit_count:730,create_at:p,author:{loginname:"BengBu-YueZhang",avatar_url:"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{id:"5c62aef20752e020af942e41",author_id:"5ba0f14737a6965f59051ab5",tab:r,content:"[docsmall在线图片压缩工具](https://docsmall.com)\r\n\r\n有需要的朋友可以用用看\r\n\r\n![20190212193207.gif](//static.cnodejs.org/FrbnjzNz3fFX1IvNNSZdiDYH4QBD)",title:"我们开发了一个在线图片压缩、PDF 压缩、合并、分割的小工具",last_reply_at:"2019-02-12T11:33:06.418Z",good:n,top:n,reply_count:0,visit_count:50,create_at:a,author:{loginname:"houxiaohou",avatar_url:"https://avatars0.githubusercontent.com/u/1525931?v=4&s=120"}},{id:"5c60e10605cc322e7b137bef",author_id:h,tab:r,content:'**摘要：** 理解JS继承。\r\n\r\n- 原文：[搞懂 JavaScript 继承原理](https://segmentfault.com/a/1190000016542417)\r\n- 作者：[前端小智](https://segmentfault.com/a/1190000017794020)\r\n\r\n**[Fundebug](https://www.fundebug.com/)经授权转载，版权归原作者所有。**\r\n\r\n在理解继承之前，需要知道 js 的三个东西：\r\n\r\n-   1. 什么是 JS 原型链\r\n-   2. this 的值到底是什么\r\n-   3. JS 的 new 到底是干什么的\r\n\r\n### 1. 什么是 JS 原型链？\r\n\r\n我们知道 JS 有对象，比如\r\n\r\n```javascript\r\nvar obj = { name: "obj" };\r\n```\r\n\r\n我们通过控制台把 obj 打印出来：\r\n\r\n![](https://image.fundebug.com/2019-02-10-01.png)\r\n\r\n我们会发现 obj 已经有几个属性（方法）了。**那么问题来了：valueOf / toString / constructor 是怎么来？我们并没有给 obj.valueOf 赋值呀。**\r\n\r\n上面这个图有点难懂，我手画一个示意图：\r\n\r\n![](https://image.fundebug.com/2019-02-10-02.png)\r\n\r\n我们发现控制台打出来的结果是：\r\n\r\n-   obj 本身有一个属性 name (这是我们给它加的)\r\n-   obj 还有一个属性叫做 **proto**(它是一个对象)\r\n-   obj 还有一个属性，包括 valueOf, toString, constructor 等\r\n-   obj.**proto**其实也有一个叫做**proto**的属性(console.log 没有显示)，值为 null\r\n\r\n现在回到我们的问题：obj 为什么会拥有 valueOf / toString / constructor 这几个属性？\r\n\r\n**答案： 这跟 **proto**有关 。**\r\n\r\n当我们「读取」 obj.toString 时，JS 引擎会做下面的事情：\r\n\r\n-   看看 obj 对象本身有没有 toString 属性。没有就走到下一步。\r\n-   看看 obj.**proto** 对象有没有 toString 属性， 发现 obj.**proto** 有 toString 属性， 于是找到了，所以 obj.toString 实际就是第 2 步中找到的 obj.**proto**.toString。\r\n-   如果 obj.**proto**没有，那么浏览器会继续查看 obj.**proto**.**proto**\r\n-   如果 obj.**proto**.**proto**也没有，那么浏览器会继续查看 obj.**proto**.**proto**.**proto**\r\n-   直到找到 toString 或者 **proto** 为 null。\r\n\r\n上面的过程，就是「读」属性的「搜索过程」。而这个「搜索过程」，是连着由 **proto** 组成的链子一直走的。**这个链子，就叫做「原型链」。**\r\n\r\n#### 共享原型链\r\n\r\n现在我们还有另一个对象\r\n\r\n```javascript\r\nvar obj2 = { name: "obj2" };\r\n```\r\n\r\n如图:\r\n\r\n![](https://image.fundebug.com/2019-02-10-03.png)\r\n\r\n那么 obj.toString 和 obj2.toString 其实是同一东西， 也就是 obj2.**proto**.toString。\r\n\r\n说白了，我们改其中的一个 **proto**.toString ，那么另外一个其实也会变!\r\n\r\n#### 差异化\r\n\r\n如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？\r\n直接赋值就好了：\r\n\r\n```javascript\r\nobj.toString = function() {\r\n    return "新的 toString 方法";\r\n};\r\n```\r\n\r\n![](https://image.fundebug.com/2019-02-10-04.png)\r\n\r\n**小结**\r\n\r\n-   [读]属性时会沿着原型链搜索\r\n-   [新增]属性时不会去看原型链\r\n\r\n### 2. this 的值到底是什么\r\n\r\n你可能遇到过这样的 JS 面试题：\r\n\r\n```javascript\r\nvar obj = {\r\n    foo: function() {\r\n        console.log(this);\r\n    }\r\n};\r\n\r\nvar bar = obj.foo;\r\nobj.foo(); // 打印出的 this 是 obj\r\nbar(); // 打印出的 this 是 window\r\n```\r\n\r\n请解释最后两行函数的值为什么不一样。\r\n\r\n#### 函数调用\r\n\r\nJS（ES5）里面有三种函数调用形式：\r\n\r\n```javascript\r\nfunc(p1, p2);\r\nobj.child.method(p1, p2);\r\nfunc.call(context, p1, p2); // 先不讲 apply\r\n```\r\n\r\n一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。\r\n我们方方老师大姥说了，你一定要记住，第三种调用形式，才是正常调用形式：\r\n\r\n```javascript\r\nfunc.call(context, p1, p2);\r\n```\r\n\r\n其他两种都是语法糖，可以等价地变为 call 形式：\r\n\r\nfunc(p1, p2)等价于 func.call(undefined, p1, p2);\r\n\r\nobj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2);\r\n\r\n至此我们的函数调用只有一种形式：\r\n\r\n```javascript\r\nfunc.call(context, p1, p2);\r\n```\r\n\r\n**这样，this 就好解释了** this 就是上面 context。\r\n\r\nthis 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。\r\n\r\n先看 func(p1, p2) 中的 this 如何确定：\r\n\r\n```javascript\r\n当你写下面代码时;\r\n\r\nfunction func() {\r\n    console.log(this);\r\n}\r\n\r\nfunc();\r\n等价于;\r\n\r\nfunction func() {\r\n    console.log(this);\r\n}\r\n\r\nfunc.call(undefined); // 可以简写为 func.call()\r\n```\r\n\r\n按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：\r\n\r\n> 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\r\n\r\n因此上面的打印结果是 window。如果你希望这里的 this 不是 window，很简单：\r\n\r\n```javascript\r\nfunc.call(obj); // 那么里面的 this 就是 obj 对象了\r\n```\r\n\r\n回到题目：\r\n\r\n```javascript\r\nvar obj = {\r\n    foo: function() {\r\n        console.log(this);\r\n    }\r\n};\r\n\r\nvar bar = obj.foo;\r\nobj.foo(); // 转换为 obj.foo.call(obj)，this 就是 obj\r\nbar();\r\n// 转换为 bar.call()\r\n// 由于没有传 context\r\n// 所以 this 就是 undefined\r\n// 最后浏览器给你一个默认的 this —— window 对象\r\n```\r\n\r\n#### [ ] 语法\r\n\r\n```javascript\r\nfunction fn() {\r\n    console.log(this);\r\n}\r\nvar arr = [fn, fn2];\r\narr[0](); // 这里面的 this 又是什么呢？\r\n```\r\n\r\n我们可以把 arr[0](https://segmentfault.com/a/1190000016542417#) 想象为 arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：\r\n\r\n```javascript\r\narr[0]();\r\n```\r\n\r\n假想为 arr.0()\r\n然后转换为 arr.0.call(arr)\r\n那么里面的 this 就是 arr 了 :)\r\n\r\n**小结：**\r\n\r\n-   this 就是你 call 一个函数时，传入的第一个参数。\r\n-   如果你的函数调用不是 call 形式， 请将其转换为 call 形式\r\n\r\n**码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 [Fundebug](https://www.fundebug.com/?utm_source=xiaozhi)。**\r\n\r\n### 3. JS 的 new 到底是干什么的？\r\n\r\n我们声明一个士兵，具有如下属性：\r\n\r\n```javascript\r\nvar 士兵 = {\r\n    ID: 1, // 用于区分每个士兵\r\n    兵种: "美国大兵",\r\n    攻击力: 5,\r\n    生命值: 42,\r\n    行走: function() {\r\n        /*走俩步的代码*/\r\n    },\r\n    奔跑: function() {\r\n        /*狂奔的代码*/\r\n    },\r\n    死亡: function() {\r\n        /*Go die*/\r\n    },\r\n    攻击: function() {\r\n        /*糊他熊脸*/\r\n    },\r\n    防御: function() {\r\n        /*护脸*/\r\n    }\r\n};\r\n```\r\n\r\n我们制造一个士兵， 只需要这样：\r\n\r\n```javascript\r\n兵营.制造(士兵);\r\n```\r\n\r\n如果需要制造 100 个士兵怎么办呢？\r\n\r\n```javascript\r\n循环 100 次吧：\r\n\r\nvar 士兵们 = []\r\nvar 士兵\r\nfor(var i=0; i<100; i++){\r\n  士兵 = {\r\n    ID: i, // ID 不能重复\r\n    兵种:"美国大兵",\r\n    攻击力:5,\r\n    生命值:42,\r\n    行走:function(){ /*走俩步的代码*/}，\r\n    奔跑:function(){ /*狂奔的代码*/  },\r\n    死亡:function(){ /*Go die*/    },\r\n    攻击:function(){ /*糊他熊脸*/   },\r\n    防御:function(){ /*护脸*/       }\r\n  }\r\n  士兵们.push(士兵)\r\n}\r\n\r\n兵营.批量制造(士兵们)\r\n```\r\n\r\n哎呀，看起来好简单\r\n\r\n#### 质疑\r\n\r\n上面的代码存在一个问题：浪费了很多内存\r\n\r\n-   行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100 个奔跑……\r\n-   这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。\r\n-   只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。\r\n\r\n#### 改进\r\n\r\n通过第一节可以知道 ，我们可以通过原型链来解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 **proto** 指向「士兵原型」。\r\n\r\n```javascript\r\nvar 士兵原型 = {\r\n  兵种:"美国大兵",\r\n  攻击力:5,\r\n  行走:function(){ /*走俩步的代码*/}，\r\n  奔跑:function(){ /*狂奔的代码*/  },\r\n  死亡:function(){ /*Go die*/    },\r\n  攻击:function(){ /*糊他熊脸*/   },\r\n  防御:function(){ /*护脸*/       }\r\n}\r\n\r\nvar 士兵们 = []\r\nvar 士兵\r\nfor(var i=0; i<100; i++){\r\n  士兵 = {\r\n    ID: i, // ID 不能重复\r\n    生命值:42\r\n  }\r\n\r\n  /*实际工作中不要这样写，因为 __proto__ 不是标准属性*/\r\n  士兵.__proto__ = 士兵原型\r\n\r\n  士兵们.push(士兵)\r\n}\r\n\r\n兵营.批量制造(士兵们)\r\n```\r\n\r\n#### 优雅？\r\n\r\n有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：\r\n\r\n```javascript\r\nfunction 士兵(ID){\r\n  var 临时对象 = {};\r\n  临时对象.__proto__ = 士兵.原型;\r\n  临时对象.ID = ID;\r\n  临时对象.生命值 = 42;\r\n\r\n  return 临时对象;\r\n}\r\n\r\n士兵.原型 = {\r\n  兵种:"美国大兵",\r\n  攻击力:5,\r\n  行走:function(){ /*走俩步的代码*/}，\r\n  奔跑:function(){ /*狂奔的代码*/  },\r\n  死亡:function(){ /*Go die*/    },\r\n  攻击:function(){ /*糊他熊脸*/   },\r\n  防御:function(){ /*护脸*/       }\r\n}\r\n\r\n// 保存为文件：士兵.js\r\n\r\n 然后就可以愉快地引用「士兵」来创建士兵了：\r\n\r\nvar 士兵们 = []\r\nfor(var i=0; i<100; i++){\r\n  士兵们.push(士兵(i))\r\n}\r\n\r\n兵营.批量制造(士兵们)\r\n```\r\n\r\nJS 之父看到大家都这么搞，觉得何必呢，我给你们个糖吃，于是 JS 之父创建了 new 关键字，可以让我们少写几行代码：\r\n\r\n![](https://image.fundebug.com/2019-02-10-05.png)\r\n\r\n**只要你在士兵前面使用 new 关键字，那么可以少做四件事情：**\r\n\r\n1. 不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；\r\n2. 不用绑定原型，因为 new 会帮你做(new 为了知道原型在哪，所以指定原型的名字 prototype);\r\n3. 不用 return 临时对象，因为 new 会帮你做；\r\n4. 不要给原型想名字了，因为 new 指定名字为 prototype。\r\n\r\n#### 这一次用 new 来写\r\n\r\n```javascript\r\nfunction 士兵(ID){\r\n  this.ID = ID\r\n  this.生命值 = 42\r\n}\r\n\r\n士兵.prototype = {\r\n  兵种:"美国大兵",\r\n  攻击力:5,\r\n  行走:function(){ /*走俩步的代码*/},\r\n  奔跑:function(){ /*狂奔的代码*/  },\r\n  死亡:function(){ /*Go die*/    },\r\n  攻击:function(){ /*糊他熊脸*/   },\r\n  防御:function(){ /*护脸*/       }\r\n}\r\n\r\n// 保存为文件：士兵.js\r\n然后是创建士兵（加了一个 new 关键字）：\r\n\r\nvar 士兵们 = []\r\nfor(var i=0; i<100; i++){\r\n  士兵们.push(new 士兵(i))\r\n}\r\n\r\n兵营.批量制造(士兵们)\r\n```\r\n\r\n**new 的作用，就是省那么几行代码。（也就是所谓的语法糖）**\r\n\r\n#### 注意 constructor 属性\r\n\r\nnew 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：\r\n\r\n```javascript\r\n士兵.prototype = {\r\n    constructor: 士兵\r\n};\r\n```\r\n\r\n如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：\r\n\r\n```javascript\r\n士兵.prototype.兵种 = "美国大兵";\r\n士兵.prototype.攻击力 = 5;\r\n士兵.prototype.行走 = function() {\r\n    /*走俩步的代码*/\r\n};\r\n士兵.prototype.奔跑 = function() {\r\n    /*狂奔的代码*/\r\n};\r\n士兵.prototype.死亡 = function() {\r\n    /*Go die*/\r\n};\r\n士兵.prototype.攻击 = function() {\r\n    /*糊他熊脸*/\r\n};\r\n士兵.prototype.防御 = function() {\r\n    /*护脸*/\r\n};\r\n```\r\n\r\n或者你也可以自己给 constructor 重新赋值：\r\n\r\n```javascript\r\n士兵.prototype = {\r\n    constructor: 士兵,\r\n    兵种: "美国大兵",\r\n    攻击力: 5,\r\n    行走: function() {\r\n        /*走俩步的代码*/\r\n    },\r\n    奔跑: function() {\r\n        /*狂奔的代码*/\r\n    },\r\n    死亡: function() {\r\n        /*Go die*/\r\n    },\r\n    攻击: function() {\r\n        /*糊他熊脸*/\r\n    },\r\n    防御: function() {\r\n        /*护脸*/\r\n    }\r\n};\r\n```\r\n\r\n### 四、继承\r\n\r\n**继承的本质就是上面的讲的原型链**\r\n\r\n#### 1)借助构造函数实现继承\r\n\r\n```javascript\r\nfunction Parent1() {\r\n    this.name = "parent1";\r\n}\r\n\r\nParent1.prototype.say = function() {};\r\n\r\nfunction Child1() {\r\n    Parent1.call(this);\r\n    this.type = "child";\r\n}\r\n\r\nconsole.log(new Child1());\r\n```\r\n\r\n打印结果：\r\n\r\n![](https://image.fundebug.com/2019-02-10-06.png)\r\n\r\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child1。有个缺点，从打印结果看出 Child1 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\r\n\r\n#### 2)借助原型链实现继承\r\n\r\n```javascript\r\n/**\r\n * 借助原型链实现继承\r\n */\r\nfunction Parent2() {\r\n    this.name = "parent2";\r\n    this.play = [1, 2, 3];\r\n}\r\n\r\nfunction Child2() {\r\n    this.type = "child2";\r\n}\r\nChild2.prototype = new Parent2();\r\n\r\nconsole.log(new Child2());\r\n\r\nvar s1 = new Child2();\r\nvar s2 = new Child2();\r\n```\r\n\r\n打印：\r\n\r\n![](https://image.fundebug.com/2019-02-10-07.png)\r\n\r\n通过一讲的，我们知道要共享莫些属性，需要 对象.**proto** = 父亲对象的.prototype,但实际上我们是不能直接 操作**proto**，这时我们可以借用 new 来做，所以\r\nChild2.prototype = new Parent2(); <=> Child2.prototype.**proto** = Parent2.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.play 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.**pro** 和 s2.**pro**指向同一个地址即 父类的 prototype。\r\n\r\n#### 3)组合方式实现继承\r\n\r\n```javascript\r\n/**\r\n * 组合方式\r\n */\r\n\r\nfunction Parent3() {\r\n    this.name = "parent3";\r\n    this.play = [1, 2, 3];\r\n}\r\n\r\nParent3.prototype.say = function() {};\r\n\r\nfunction Child3() {\r\n    Parent3.call(this);\r\n    this.type = "child3";\r\n}\r\n\r\nChild3.prototype = new Parent3();\r\n\r\nvar s3 = new Child3();\r\nvar s4 = new Child3();\r\ns3.play.push(4);\r\nconsole.log(new Child3());\r\nconsole.log(s3.play, s4.play);\r\n```\r\n\r\n打印:\r\n\r\n![](https://image.fundebug.com/2019-02-10-08.png)\r\n\r\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 var s3 = new Child3()对应 Child3.prototype = new Parent3()还要 new 一次。\r\n\r\n#### 4)组合继承的优化 1\r\n\r\n```javascript\r\nfunction Parent4() {\r\n    this.name = "parent4";\r\n    this.play = [1, 2, 3];\r\n}\r\n\r\nParent4.prototype.say = function() {};\r\n\r\nfunction Child4() {\r\n    Parent4.call(this);\r\n    this.type = "child4";\r\n}\r\n\r\nChild4.prototype = Parent4.prototype;\r\n\r\nvar s5 = new Child4();\r\nvar s6 = new Child4();\r\n```\r\n\r\n这边主要为 Child4.prototype = Parent4.prototype， 因为我们通过构造函数就可以拿到所有属性和实例的方法，那么现在我想继承父类的原型对象，所以你直接赋值给我就行，不用在去 new 一次父类。其实这种方法还是有问题的，如果我在控制台打印以下两句:\r\n\r\n![](https://image.fundebug.com/2019-02-10-09.png)\r\n\r\n从打印可以看出，此时我是没有办法区分一个对象 是直接 由它的子类实例化还是父类呢？我们还有一个方法判断来判断对象是否是类的实例，那就是用 constructor,我在控制台打印以下内容：\r\n\r\n![](https://image.fundebug.com/2019-02-10-10.png)\r\n\r\n咦，你会发现它指向的是父类 ，这显然不是我们想要的结果， 上面讲过我们 prototype 里面有一个 constructor, 而我们此时子类的 prototype 指向是 父类的 prototye ,而父类 prototype 里面的 contructor 当然是父类自己的，这个就是产生该问题的原因。\r\n\r\n#### 组合继承的优化 2\r\n\r\n```javascript\r\n/**\r\n * 组合继承的优化2\r\n */\r\n\r\nfunction Parent5() {\r\n    this.name = "parent4";\r\n    this.play = [1, 2, 3];\r\n}\r\n\r\nParent5.prototype.say = function() {};\r\n\r\nfunction Child5() {\r\n    Parent5.call(this);\r\n    this.type = "child4";\r\n}\r\n\r\nChild5.prototype = Object.create(Parent5.prototype);\r\n```\r\n\r\n这里主要使用**Object.create()**，它的作用是将对象继承到**proto**属性上。举个例子：\r\n\r\n```javascript\r\nvar test = Object.create({ x: 123, y: 345 });\r\nconsole.log(test); //{}\r\nconsole.log(test.x); //123\r\nconsole.log(test.__proto__.x); //3\r\nconsole.log(test.__proto__.x === test.x); //true\r\n```\r\n\r\n那大家可能说这样解决了吗，其实没有解决,因为这时 Child5.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent5.prototype, constructor 还是 Parent5 ,所以要给 Child5.prototype 写自己的 constructor:\r\n\r\n```javascript\r\nChild5.prototype = Object.create(Parent5.prototype);\r\nChild5.prototype.constructor = Child5;\r\n```\r\n\r\n#### 参考\r\n\r\n-   [什么是 JS 原型链？](https://zhuanlan.zhihu.com/p/23090041?refer=study-fe)\r\n-   [this 的值到底是什么？一次说清楚](https://zhuanlan.zhihu.com/p/23804247)\r\n-   [JS 的 new 到底是干什么的？](https://zhuanlan.zhihu.com/p/23987456?refer=study-fe)\r\n\r\n### 关于Fundebug\r\n\r\n[Fundebug](https://www.fundebug.com/)专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家[免费试用](https://www.fundebug.com/team/create)！\r\n\r\n![](https://static.fundebug.cn/wechat_slogan.png)',title:"搞懂 JavaScript 继承原理",last_reply_at:"2019-02-12T10:06:13.818Z",good:n,top:n,reply_count:3,visit_count:273,create_at:s,author:{loginname:u,avatar_url:d}},{id:"5c203e7776c4964062a1ce04",author_id:"5129b03cdf9e9fcc58f3673c",tab:r,content:"各位小哥哥小姐姐，分享个圣诞桌面祝大家圣诞快乐\r\nhttp://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3\r\n![QQ截图20181224103521.jpg](//static.cnodejs.org/FrFmzitH9OluHpCz3xAZlMPwHjww)",title:"圣诞桌面 Merry Christmas",last_reply_at:"2019-02-12T09:25:17.269Z",good:n,top:n,reply_count:4,visit_count:521,create_at:"2018-12-24",author:{loginname:"yunfei",avatar_url:"https://avatars1.githubusercontent.com/u/6891001?v=4&s=120"}},{id:"5c61274005cc322e7b137d2d",author_id:"5ab852d6320bb09d69e231f1",tab:t,content:"输入汉字拼音首字母,模糊查询数据,目前只有数据中预存拼音这一种方法么?比如数据库表中有name   pinyin2个字段 \r\n\t里面存储数据 name:张三 pinyin:zhangsan,name:赵四 pinyin:zhaosi,查询输入zs,后台查询数据库pinyin这个字段,结果集为张三和赵四,就和高铁app上面查询车站那个搜索需求是一样的,主要前期设计数据库的时候没有设计pinyin这个字段,现在客户需求这个功能...有没有更好的办法解决呢?",title:"请教:输入汉字拼音首字母,模糊查询数据",last_reply_at:"2019-02-12T09:00:53.197Z",good:n,top:n,reply_count:5,visit_count:259,create_at:s,author:{loginname:"iori2882",avatar_url:"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{id:"5c580a4105cc322e7b137466",author_id:"5a751a679288dc81532884bf",tab:t,content:"我现在有一套多项目多页面的前端代码，所有的项目都共用基础库（vue、echarts等）、公共js（自己写的公共方法以及配置）。大致结构如下\r\n![image.png](//static.cnodejs.org/Fn2a95Q-cNNM5mm86EXMrUf0oasG)\r\n\r\n说明：demo和test分别是两个独立的多页面项目，但是共用基础库（lib）和公共js（util）。基础库是长久不变的，可以由所有项目公用，但是公共js是可能变化的，所以我希望在打包的时候，公共js能打包到每个项目里面，这个项目的多个页面使用这一个公共js。 另外一个项目的多个页面，使用另外的公共js。\r\n\r\n如下图，希望的结果是util.js在demo/js和test/js下各有一分，demo和test分别引用各自js/下的的uitl。\r\n![image.png](//static.cnodejs.org/Fj4rTRhh-879q4ltMlkqMrOGR8FI)\r\n\r\n这样我就可以在修改公共代码后，只上传dist/demo，来达到只更新demo项目下的公共js的目的。\r\nutil配置代码是这样的：请问大佬，这个util怎么才能配置成活的呢\r\n![image.png](//static.cnodejs.org/FsJzOidkWfIRmLbpcAvTeYHJgmzu)",title:"webpack4多页面多项目工程的公共js提取问题",last_reply_at:"2019-02-12T08:52:09.271Z",good:n,top:n,reply_count:3,visit_count:545,create_at:p,author:{loginname:"hejiaoshou",avatar_url:"https://avatars0.githubusercontent.com/u/24504661?v=4&s=120"}},{id:"5c6287ad05cc322e7b13816f",author_id:"5af3dec21b02288048bd0eb1",tab:t,content:"node的第三方模块中支持mysql schema的模块吗？像使用mongoose中的schema一样。",title:"node的第三方模块中支持mysql schema的模块吗？",last_reply_at:"2019-02-12T08:45:33.665Z",good:n,top:n,reply_count:0,visit_count:82,create_at:a,author:{loginname:"witlxx",avatar_url:"https://avatars0.githubusercontent.com/u/25942898?v=4&s=120"}},{id:"5c50213fa4647e02328f21f8",author_id:"57bbcb58b32043f532d40e6f",tab:t,content:"最近想学个 node 框架（支持 ts），发现这仨框架应该算是比较流行的了（express 略古老，koajs 还要自己拼装插件）。\r\n\r\n不知道这三个框架哪一个比较合适？\r\n\r\n打算的架构是 nodejs + redis + mongodb/mysql。",title:"Egg.js/thinkjs/nestjs 该如何选择？",last_reply_at:"2019-02-12T07:16:14.089Z",good:n,top:n,reply_count:30,visit_count:1277,create_at:"2019-01-29",author:{loginname:"JZLeung",avatar_url:"https://avatars2.githubusercontent.com/u/7995232?v=4&s=120"}},{id:"5c53f19f05cc322e7b136e1c",author_id:"56ce68bc842c03521a73520e",tab:t,content:'在看《JavaScript高级程序设计》，章节6.2.2中最后（147页）提供了一种构造函数定义方式，但作者自己又说有问题，但并未讲清楚问题是什么，所以请大家讲讲？\r\n```\r\nfunction Person(name, age, job){\r\n this.name = name;\r\n this.age = age;\r\n this.job = job;\r\n this.sayName = sayName;\r\n}\r\nfunction sayName(){\r\n alert(this.name);\r\n}\r\nvar person1 = new Person("Nicholas", 29, "Software Engineer");\r\nvar person2 = new Person("Greg", 27, "Doctor");\r\nperson1.sayName===person2.sayName; // true\r\n```\r\n这段代码的原文评注如下：\r\n在这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们\r\n将sayName 属性设置成等于全局的sayName 函数。这样一来，由于sayName 包含的是一个指向函数\r\n的指针，因此person1 和person2 对象就共享了在全局作用域中定义的同一个sayName()函数。这\r\n样做确实解决了两个函数做同一件事的问题，可是新问题又来了：**在全局作用域中定义的函数实际上只\r\n能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方\r\n法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。**\r\n\r\n有木有觉得粗体这段不知所云？',title:"《JavaScript高级程序设计》中的一个疑点",last_reply_at:"2019-02-12T06:59:37.995Z",good:n,top:n,reply_count:5,visit_count:739,create_at:"2019-02-01",author:{loginname:"JarvisQJ",avatar_url:"https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"}},{id:"5c6265b405cc322e7b138022",author_id:"511350f6df9e9fcc58856443",tab:r,content:'# 前言\r\n转眼新年过了，开始了搬砖的日子。在这里给大家拜个晚年，送上一些小知识，希望大家好搬砖！\r\n# klg-tracer\r\n\r\n链路追踪工具，base on [pandora](https://github.com/midwayjs/pandora)\r\n\r\n## Installation\r\n\r\n```bash\r\nnpm install klg-tracer\r\n```\r\n\r\nNode.js >= 8.2.1 required.\r\n\r\n## Features\r\n\r\nPandora 提供基于 OpenTracing 标准的链路追踪信息，在此基础上，klg-tracer 自定义了一些 tags，并支持将 tracer 信息写入 mongo。\r\n\r\n## QuickStart\r\n\r\n### 一、配合 Pandora 使用，自定义tags\r\n\r\nTODO\r\n1. export 拓展好的类\r\n2. 覆盖 Pandora 的默认配置\r\n\r\n### 二、将 tracer 结果写入 Mongo\r\n\r\napp.ts\r\n```js\r\nimport {TraceService, Tracer} from \'klg-tracer\'\r\n\r\nnew TraceService().registerHooks({\r\n    httpServer: {\r\n      useKoa:true, // 在 koa 设置钩子，比直接在 http 层设置钩子稳定\r\n      // 过滤器，只记录特定接口, 注意 return true 的才会被过滤\r\n      requestFilter: function (req) {\r\n        const urlParsed = url.parse(req.url, true);\r\n        return urlParsed.pathname.indexOf(\'product/\') === -1;\r\n      }\r\n    }\r\n  }).registerMongoReporter({\r\n    mongoUrl: config.database.mongodb[0].url,\r\n    collectionName: \'tracer\'\r\n  });\r\n\r\n```\r\n\r\n完整的配置可以见 src/domain\r\n\r\n```typescript\r\ninterface TracerOptions {\r\n  httpServer?: {\r\n    recordGetParams?: boolean,    // 是否记录 query\r\n    recordPostData?: boolean,     // 是否记录 post data\r\n    recordResponse?: boolean,     // 是否记录 response\r\n    requestFilter?: requestFilter,  // 过滤器\r\n    interceptor?: interceptor       // 中间件 TODO\r\n  },\r\n  httpClient?: {\r\n    enabled: boolean, options?: {\r\n      recordGetParams?: boolean,\r\n      recordPostData?: boolean,\r\n      recordResponse?: boolean\r\n    }\r\n  },\r\n  mongodb?: { enabled: boolean, options?: any }\r\n}\r\n```\r\n\r\n\r\n启动你的 Web 服务并访问，相关的请求信息将会写入 tracer 表中。\r\n\r\nSearch:\r\n\r\n```js\r\n\ufeffdb.tracer.find({name : \'http-server\'}).sort({_id : -1})\r\n```\r\n\r\nResult:\r\n\r\n```js\r\n{\r\n    "_id" : ObjectId("5ad99bd3f29cf14de64516b3"),\r\n    "tags" : {\r\n        "httpMethod" : "POST",\r\n        "url" : "/api/v1/account/register",\r\n        "data" : {\r\n            "userId" : "5527da927855af35354c39eb",\r\n            "userRole" : "INVESTOR"\r\n        },\r\n        "response" : {\r\n            "code" : 0,\r\n            "message" : "success",\r\n            "data" : {\r\n                "html" : "html"\r\n            }\r\n        }\r\n    },\r\n    "traceId" : "6e11fe95c2035a7a",\r\n    "name" : "http-server",\r\n    "timestamp" : 1524210643694.0,\r\n    "duration" : 152,\r\n    "createdAt" : ISODate("2018-04-20T07:50:43.874Z"),\r\n    "updatedAt" : ISODate("2018-04-20T07:50:43.874Z"),\r\n    "__v" : 0\r\n}\r\n```\r\n\r\n### Tracer tags\r\n\r\n1. http server\r\n- http.method\r\n- http.path  // path\r\n- http.query    // query string\r\n- http.data  // post body, only json\r\n- http.response\r\n\r\n2. http client\r\n- http.method\r\n- http.url  // path\r\n- http.hostname  // send to where\r\n- http.port\r\n- http.query\r\n- http.data\r\n- http.response\r\n- http.response_size\r\n- http.status_code\r\n- http.error_code\r\n\r\n3. mongo\r\ntodo\r\n\r\n## Test\r\n\r\n```bash\r\n$ npm i\r\n$ npm test\r\n```\r\n\r\n## How it works\r\n\r\n### tracer\r\n\r\nimplements session with [async_hooks](https://nodejs.org/api/async_hooks.html) and [cls-hooked](https://github.com/Jeff-Lewis/cls-hooked)\r\n\r\n### hook\r\n\r\nserve : hack http createServer method, register listener.\r\n\r\nhttp-client : hack http request method, register listener.\r\n\r\n## ChangeLog\r\n\r\n3.0.0\r\n- 基于 Pandorajs 重做，目前只提供 http-server http-client mongo 三个位置的监听\r\n\r\n1.2.0\r\n- koa-server hook add requestFilter options\r\n\r\n1.1.0\r\n- koa-server hook add intercept options\r\n\r\n1.0.3\r\n- http-client hook trace request parameters and response\r\n\r\n1.0.0\r\n- add http-server koa-server hook\r\n- add http-client hook\r\n- add mongo report\r\n\r\n## 常见问题\r\n1 thenable 函数会 break cls 的上下文，像 mongoose 和 superagent 都是在 prototype 里添加 then function 来支持 Promise 的，所有都会有这个问题。\r\n目前只能通过改变写法来避免这个问题，例如：\r\n\r\nbreak session\r\n```js\r\nawait User.findOne({})\r\n```\r\n\r\nwork\r\n```js\r\nawait User.findOne({}).then()\r\n```\r\n\r\n详情见此 issue https://github.com/midwayjs/pandora/issues/221\r\n\r\n2 mongodb nodejs driver 3.0 版本升级了 apm 的实现，Pandorajs 还未支持\r\n详情见此 issue https://github.com/midwayjs/pandora/issues/239\r\n\r\n--- \r\n著作权归本文作者所有，未经授权，请勿转载，谢谢。',title:"AI考拉技术分享-Node基础架构专题（三）",last_reply_at:"2019-02-12T06:20:36.609Z",good:n,top:n,reply_count:0,visit_count:112,create_at:a,author:{loginname:"kalengo",avatar_url:"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{id:"5c62403805cc322e7b137f8b",author_id:h,tab:r,content:"![js_closure.png](//static.cnodejs.org/FmrUNUrOP4SEOWrAMXQScFmOYqfR)\r\n**摘要：** 理解JS闭包。\r\n\r\n- 原文：[我从来不理解JavaScript闭包，直到有人这样向我解释它...](https://segmentfault.com/a/1190000017136436)\r\n- 作者：[前端小智](https://segmentfault.com/a/1190000017794020)\r\n\r\n**[Fundebug](https://www.fundebug.com/)经授权转载，版权归原作者所有。**\r\n\r\n正如标题所述，JavaScript闭包对我来说一直有点神秘,看过很多闭包的文章，在工作使用过闭包，有时甚至在项目中使用闭包，但我确实是这是在使用闭包的知识。\r\n\r\n最近看国外的一些文章，终于，有人用于一种让我明白方式对闭包进行了解释，我将在本文中尝试使用这种方法来解释闭包。\r\n\r\n### 准备\r\n\r\n在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。\r\n\r\n这篇[文章](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/)是执行上下文 很不错的入门教程，文章中提到：\r\n\r\n> 当代码在JavaScript中运行时，执行代码的环境非常重要，并将概括为以下几点：\r\n>\r\n> **全局代码**——第一次执行代码的默认环境。\r\n>\r\n> **函数代码**——当执行流进入函数体时。\r\n>\r\n> (…) —— 我们当作 执行上下文 是当前代码执行的一个环境与范围。\r\n\r\n换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么?\r\n\r\n以下几个步骤：\r\n\r\n- JavaScript创建一个新的执行上下文，我们叫作本地执行上下文。\r\n- 这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。\r\n- 新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。\r\n\r\n函数什么时候结束?当它遇到一个return语句或一个结束括号}。\r\n\r\n当一个函数结束时，会发生以下情况:\r\n\r\n- 这个本地执行上下文从执行堆栈中弹出。\r\n- 函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined。\r\n- 这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。\r\n\r\n#### 基础的例子\r\n\r\n在讨论闭包之前，让我们看一下下面的代码：\r\n\r\n```javascript\r\n1: let a = 3\r\n2: function addTwo(x) {\r\n3:   let ret = x + 2\r\n4:   return ret\r\n5: }\r\n6: let b = addTwo(a)\r\n7: console.log(b)\r\n```\r\n\r\n为了理解JavaScript引擎是如何工作的，让我们详细分析一下：\r\n\r\n- 在第1行，我们在全局执行上下文中声明了一个新变量a，并将赋值为3。\r\n- 接下来就变得棘手了，第2行到第5行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为`addTwo`的新变量,我们给它分配了什么?一个函数定义。两个括号{}之间的任何内容都被分配给`addTwo`，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。\r\n- 现在我们在第6行。它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为`b`，变量一经声明，其值即为undefined。\r\n- 接下来，仍然在第6行，我们看到一个赋值操作符。我们准备给变量`b`赋一个新值，接下来我们看到一个函数被调用。当您看到一个变量后面跟着一个圆括号(…)时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量`b`。\r\n- 但是首先我们需要调用标记为`addTwo`的函数。JavaScript将在其全局执行上下文内存中查找名为`addTwo`的变量。噢，它找到了一个，它是在步骤2(或第2 - 5行)中定义的。变量`add2`包含一个函数定义。注意，变量`a`作为参数传递给函数。JavaScript在全局执行上下文内存中搜索变量`a`，找到它，发现它的值是3，并将数字3作为参数传递给函数，准备好执行函数。\r\n- 现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为“addTwo执行上下文”，执行上下文被推送到调用堆栈上。在addTwo执行上下文中，我们要做的第一件事是什么?\r\n- 你可能会说，“在addTwo执行上下文中声明了一个新的变量ret”，这是不对的。正确的答案是，我们需要先看函数的参数。在addTwo执行上下文中声明一个新的变量`x``，因为值3是作为参数传递的，所以变量x被赋值为3。\r\n- 下一步是:在addTwo执行上下文中声明一个新的变量`ret`。它的值被设置为 undefined(第三行)。\r\n- 仍然是第3行，需要执行一个相加操作。首先我们需要`x`的值，JavaScript会寻找一个变量`x`，它会首先在`addTwo`执行上下文中寻找，找到了一个值为3。第二个操作数是数字2。两个相加结果为5就被分配给变量`ret`。\r\n- 第4行，我们返回变量`ret`的内容，在addTwo执行上下文中查找，找到值为5，返回，函数结束。\r\n- 第4 - 5行，函数结束。addTwo执行上下文被销毁，变量`x`和`ret`被消去了，它们已经不存在了。addTwo执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数`addTw`o是从全局执行上下文调用的。\r\n- 现在我们继续第4步的内容，返回值5被分配给变量`b`，程序仍然在第6行。\r\n- 在第7行，`b`的值 5 被打印到控制台了。\r\n\r\n对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。\r\n\r\n### 词法作用域（Lexical scope）\r\n\r\n我们需要理解词法作用域的一些知识。请看下面的例子：\r\n\r\n```javascript\r\n1: let val1 = 2\r\n2: function multiplyThis(n) {\r\n3:   let ret = n * val1\r\n4:   return ret\r\n5: }\r\n6: let multiplied = multiplyThis(6)\r\n7: console.log('example of scope:', multiplied)\r\n```\r\n\r\n这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 undefined)。\r\n\r\n下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）：\r\n\r\n- 在全局执行上下文中声明一个新的变量`val1`，并将其赋值为2。\r\n- 行2 - 5，声明一个新的变量 `multiplyThis`，并给它分配一个函数定义。\r\n- 第六行，声明一个在全局执行上下文 `multiplied` 新变量。\r\n- 从全局执行上下文内存中查找变量`multiplyThis`，并将其作为函数执行，传递数字 6 作为参数。\r\n- 新函数调用(创建新执行上下文），创建一个新的 `multiplyThis` 函数执行上下文。\r\n- 在 `multiplyThis` 执行上下文中，声明一个变量n并将其赋值为6\r\n- 第 3 行。在`multiplyThis`执行上下文中，声明一个变量`ret`。\r\n- 继续第 3 行。对两个操作数 n 和 val1 进行乘法运算.在`multiplyThis`执行上下文中查找变量 `n`。我们在步骤6中声明了它,它的内容是数字6。在`multiplyThis`执行上下文中查找变量`val1`。`multiplyThis`执行上下文没有一个标记为 val1 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 `val1`。哦，是的、在那儿，它在步骤1中定义，数值是2。\r\n- 继续第 3 行。将两个操作数相乘并将其赋值给`ret`变量，6 * 2 = 12，ret现在值为 12。\r\n- 返回`ret`变量，销毁`multiplyThis`执行上下文及其变量 `ret` 和 `n` 。变量 `val1` 没有被销毁，因为它是全局执行上下文的一部分。\r\n- 回到第6行。在调用上下文中，数字 12 赋值给 `multiplied` 的变量。\r\n- 最后在第7行，我们在控制台中打印 `multiplied` 变量的值\r\n\r\n在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是**词法作用域（Lexical scope）**。\r\n\r\n### 返回函数的函数\r\n\r\n在第一个例子中，函数`addTwo`返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于理解闭包非常重要。看粟子：\r\n\r\n```javascript\r\n 1: let val = 7\r\n 2: function createAdder() {\r\n 3:   function addNumbers(a, b) {\r\n 4:     let ret = a + b\r\n 5:     return ret\r\n 6:   }\r\n 7:   return addNumbers\r\n 8: }\r\n 9: let adder = createAdder()\r\n10: let sum = adder(val, 8)\r\n11: console.log('example of function returning a function: ', sum)\r\n```\r\n\r\n让我们回到分步分解：\r\n\r\n- 第一行。我们在全局执行上下文中声明一个变量`val`并赋值为 7。\r\n- 行2 - 8。我们在全局执行上下文中声明了一个名为 `createAdder` 的变量，并为其分配了一个函数定义。第3至7行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到那个变量(`createAdder`)中。\r\n- 第9行。我们在全局执行上下文中声明了一个名为 `adder` 的新变量，暂时，值为 undefined。\r\n- 第9行。我们看到括号()，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为`createAdder` 的变量，它是在步骤2中创建的。好吧，我们调用它。\r\n- 调用函数时，执行到第2行。创建一个新的`createAdder`执行上下文。我们可以在`createAdder`的执行上下文中创建自有变量。js 引擎将`createAdder`的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分.\r\n- 第 3 - 6 行。我们有一个新的函数声明，我们在`createAdder`执行上下文中创建一个变量addNumbers。这很重要，`addnumber`只存在于`createAdder`执行上下文中。我们将函数定义存储在名为 `addNumbers`` 的自有变量中。\r\n- 在第7行，我们返回变量`addNumbers`的内容。js引擎查找一个名为`addNumbers`的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返`addNumbers`的定义。第4行和第5行括号之间的内容构成该函数定义。\r\n- 返回时，`createAdder`执行上下文将被销毁。`addNumbers` 变量不再存在。但`addNumbers`函数定义仍然存在，因为它返回并赋值给了adder 变量。\r\n- 第10行。我们在全局执行上下文中定义了一个新的变量 `sum`，先负值为 undefined;\r\n- 接下来我们需要执行一个函数。哪个函数?是名为`adder`变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。\r\n- 让我们查找这两个参数，第一个是我们在步骤1中定义的变量`val`，它表示数字7，第二个是数字8。\r\n- 现在我们要执行这个函数，函数定义概述在第3-5行，因为这个函数是匿名，为了方便理解，我们暂且叫它`adder`吧。这时创建一个`adder`函数执行上下文，在`adder`执行上下文中创建了两个新变量 `a` 和 `b`。它们分别被赋值为 7 和 8，因为这些是我们在上一步传递给函数的参数。\r\n- 第 4 行。在`adder`执行上下文中声明了一个名为`ret`的新变量,\r\n- 第 4 行。将变量`a`的内容和变量`b`的内容相加得15并赋给ret变量。\r\n- `ret`变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量`a`、`b`和`ret`不再存在。\r\n- 返回值被分配给我们在步骤9中定义的`sum`变量。\r\n- 我们将`sum`的值打印到控制台。\r\n- 如预期，控制台将打印15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到return或右括号}时执行完成。\r\n\r\n**码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 [Fundebug](https://www.fundebug.com/?utm_source=xiaozhi)。**\r\n\r\n### 最后,一个闭包\r\n\r\n看看下面的代码，并试着弄清楚会发生什么。\r\n\r\n```javascript\r\n 1: function createCounter() {\r\n 2:   let counter = 0\r\n 3:   const myFunction = function() {\r\n 4:     counter = counter + 1\r\n 5:     return counter\r\n 6:   }\r\n 7:   return myFunction\r\n 8: }\r\n 9: const increment = createCounter()\r\n10: const c1 = increment()\r\n11: const c2 = increment()\r\n12: const c3 = increment()\r\n13: console.log('example increment', c1, c2, c3)\r\n```\r\n\r\n现在，我们已经从前两个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它：\r\n\r\n- 行1 - 8。我们在全局执行上下文中创建了一个新的变量`createCounter`，并赋值了一个的函数定义。\r\n- 第9行。我们在全局执行上下文中声明了一个名为`increment`的新变量。\r\n- 第9行。我们需要调用`createCounter`函数并将其返回值赋给`increment`变量。\r\n- 行1 - 8。调用函数，创建新的本地执行上下文。\r\n- 第2行。在本地执行上下文中，声明一个名为`counter`的新变量并赋值为 0;\r\n- 行3 - 6。声明一个名为`myFunction`的新变量，变量在本地执行上下文中声明,变量的内容是为第4行和第5行所定义。\r\n- 第7行。返回`myFunction`变量的内容，删除本地执行上下文。变量`myFunction `和`counter`不再存在。此时控制权回到了调用上下文。\r\n- 第9行。在调用上下文(全局执行上下文)中，`createCounter`返回的值赋给了`increment`，变量`increment`现在包含一个函数定义内容为`createCounter`返回的函数。它不再标记为`myFunction``，但它的定义是相同的。在全局上下文中，它是的标记为`labeledincrement`。\r\n- 第10行。声明一个新变量(c1)。\r\n- 继续第10行。查找`increment`变量，它是一个函数并调用它。它包含前面返回的函数定义，如第4-5行所定义的。\r\n- 创建一个新的执行上下文。没有参数。开始执行函数。\r\n- 第4行。counter=counter + 1。在本地执行上下文中查找`counter`变量。我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有`counter`变量。Javascript会将其计算为counter = undefined + 1，声明一个标记为`counter`的新局部变量，并将其赋值为number 1，因为undefined被当作值为 0。\r\n- 第5行。我们变量`counter`的值(1)，我们销毁本地执行上下文和`counter`变量。\r\n- 回到第10行。返回值(1)被赋给c1。\r\n- 第11行。重复步骤10-14，c2也被赋值为1。\r\n- 第12行。重复步骤10-14，c3也被赋值为1。\r\n- 第13行。我们打印变量c1 c2和c3的内容。\r\n\r\n你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录1,1,1。而是记录1,2,3。这个是为什么?\r\n\r\n不知怎么滴，`increment`函数记住了那个`cunter`的值。这是怎么回事?\r\n\r\n`counter`是全局执行上下文的一部分吗?尝试 console.log(counter)，得到undefined的结果,显然不是这样的。\r\n\r\n也许，当你调用`increment`时，它会以某种方式返回它创建的函数(createCounter)?这怎么可能呢?变量`increment`包含函数定义，而不是函数的来源，显然也不是这样的。\r\n\r\n所以一定有另一种机制。**闭包**，我们终于找到了，丢失的那块。\r\n\r\n它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。\r\n\r\n所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的。\r\n\r\n```javascript\r\n 1: function createCounter() {\r\n 2:   let counter = 0\r\n 3:   const myFunction = function() {\r\n 4:     counter = counter + 1\r\n 5:     return counter\r\n 6:   }\r\n 7:   return myFunction\r\n 8: }\r\n 9: const increment = createCounter()\r\n10: const c1 = increment()\r\n11: const c2 = increment()\r\n12: const c3 = increment()\r\n13: console.log('example increment', c1, c2, c3)\r\n```\r\n\r\n- 同上， 行1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。\r\n- 同上，第9行。我们在全局执行上下文中声明了一个名为`increment`的新变量。\r\n- 同上，第9行。我们需要调用`createCounter`函数并将其返回值赋给`increment`变量。\r\n- 同上，行1 - 8。调用函数，创建新的本地执行上下文。\r\n- 同上，第2行。在本地执行上下文中，声明一个名为`counter`的新变量并赋值为 0 。\r\n- 行3 - 6。声明一个名为`myFunction`的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量`counter`(值为0)。\r\n- 第7行。返回`myFunction`变量的内容,删除本地执行上下文。`myFunction`和`counter`不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。\r\n- 第9行。在调用上下文(全局执行上下文)中，`createCounter`返回的值被指定为`increment`，变量`increment`现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为`myFunction`，但它的定义是相同的,在全局上下文中，称为`increment`。\r\n- 第10行。声明一个新变量(c1)。\r\n- 继续第10行。查找变量`increment`，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。\r\n- 创建一个新的执行上下文，没有参数，开始执行函数。\r\n- 第4行。counter = counter + 1，寻找变量 `counter`，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为`counter`的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 `counter`。\r\n- 第5行。我们返回`counter的值`，销毁本地执行上下文。\r\n- 回到第10行。返回值(1)被赋给变量`c1`。\r\n- 第11行。我们重复步骤10-14。这一次，在闭包中此时变量`counter`的值是1。它在第12步设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。\r\n- 第12行。重复步骤10-14,`c3`被赋值为3。\r\n- 第13行。我们打印变量c1 c2和c3的值。\r\n\r\n您可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数?答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。\r\n\r\n当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。\r\n\r\n### 闭包不是那么简单\r\n\r\n有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例，如下面的代码所示：\r\n\r\n```javascript\r\nlet c = 4\r\nconst addX = x => n => n + x\r\nconst addThree = addX(3)\r\nlet d = addThree(c)\r\nconsole.log('example partial application', d)\r\n```\r\n\r\n如果箭头函数让您感到困惑，下面是同样效果：\r\n\r\n```javascript\r\nlet c = 4\r\nfunction addX(x) {\r\n  return function(n) {\r\n     return n + x\r\n  }\r\n}\r\nconst addThree = addX(3)\r\nlet d = addThree(c)\r\nconsole.log('example partial application', d)\r\n```\r\n\r\n我们声明一个能用加法函数`addX`，它接受一个参数(x)并返回另一个函数。返回的函数还接受一个参数并将其添加到变量`x`中。\r\n\r\n变量`x`是闭包的一部分，当变量`addThree`在本地上下文中声明时，它被分配一个函数定义和一个闭包，闭包包含变量x。\r\n\r\n所以当`addThree`被调用并执行时，它可以从闭包中访问变量`x`以及为参数传递变量`n`并返回两者的和 7。\r\n\r\n### 总结\r\n\r\n我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。\r\n\r\n### 参考\r\n\r\n- [解密JavaScript闭包](https://blog.fundebug.com/2017/07/31/javascript-closure/)\r\n- [10个JavaScript难点](https://blog.fundebug.com/2017/07/17/10-javascript-difficulties/)\r\n\r\n### 关于Fundebug\r\n\r\n[Fundebug](https://www.fundebug.com/)专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家[免费试用](https://www.fundebug.com/team/create)！\r\n\r\n![](https://static.fundebug.cn/wechat_slogan.png)",title:"我从来不理解JavaScript闭包，直到有人这样向我解释它...",last_reply_at:"2019-02-12T03:40:40.147Z",good:n,top:n,reply_count:0,visit_count:253,create_at:a,author:{loginname:u,avatar_url:d}},{id:"5c0a92e415a4d545e3f4c5d7",author_id:"5bc9f0ca9545eaf107b9ccdd",tab:t,content:"要怎么去学习",title:"如何学习angular",last_reply_at:"2019-02-12T03:30:02.714Z",good:n,top:n,reply_count:14,visit_count:1293,create_at:"2018-12-07",author:{loginname:"hhffhh",avatar_url:"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}}],tab:"",loading:n,pageInfo:{page:1,limit:15,total:1e3}},user:{loginInfo:{},userInfo:{},messages:{has_read_messages:[],hasnot_read_messages:[]},accesstoken:"",loading:n}},serverRendered:!0}}(!1,"share","ask",0,0,"2019-02-12",0,0,"2019-02-11","Fundebug","https://avatars2.githubusercontent.com/u/26496557?v=4&s=120","2019-02-04",0,"58d140302c8bf2a836456213")</script><script src="/nuxt-blog/_nuxt/77a49a90f4c6b7205154.js" defer></script><script src="/nuxt-blog/_nuxt/865c83433feab54c1410.js" defer></script><script src="/nuxt-blog/_nuxt/47daf545fd64040ca35e.js" defer></script><script src="/nuxt-blog/_nuxt/17ceb88e98e01c7e5425.js" defer></script><script src="/nuxt-blog/_nuxt/6081eb96f6d7595dbdc5.js" defer></script>
  </body>
</html>
