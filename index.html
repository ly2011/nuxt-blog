<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="My stunning Nuxt.js project" name="description" data-hid="description"><title data-n-head="true">nuxt-blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><base href="/nuxt-blog/"><link href="/nuxt-blog/_nuxt/manifest.99e36d02ae9d35f9a67a.js" rel="preload" as="script"><link href="/nuxt-blog/_nuxt/vendor.99e36d02ae9d.js" rel="preload" as="script"><link href="/nuxt-blog/_nuxt/hare.3ad678fdff0b.js" rel="preload" as="script"><link href="/nuxt-blog/_nuxt/hare.1210ab93f72a.css" rel="preload" as="style"><link href="/nuxt-blog/_nuxt/layouts_default.3e9b7a2d9551da30542e.js" rel="preload" as="script"><link href="/nuxt-blog/_nuxt/pages_index.1a1dabc786aba819b9a7.js" rel="preload" as="script"><link href="/nuxt-blog/_nuxt/pages_topic_index.b0d7cafae26ed5f2ebbe.js" rel="prefetch"><link href="/nuxt-blog/_nuxt/pages_topic_create.ac9ee0c71490d976a9bd.js" rel="prefetch"><link href="/nuxt-blog/_nuxt/pages_my_messages.678e51480df571961479.js" rel="prefetch"><link href="/nuxt-blog/_nuxt/pages_register.7ac68d24410515f9e20e.js" rel="prefetch"><link href="/nuxt-blog/_nuxt/pages_login.56fa4d7a486b0b2280f8.js" rel="prefetch"><link href="/nuxt-blog/_nuxt/hare.1210ab93f72a.css" rel="stylesheet"><style data-vue-ssr-id="b30ab75e:0">html{font-family:Source Sans Pro,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:14px;word-spacing:1px;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}.button--green{display:inline-block;-webkit-border-radius:4px;border-radius:4px;border:1px solid #3b8070;color:#3b8070;text-decoration:none;padding:10px 30px}.button--green:hover{color:#fff;background-color:#3b8070}.button--grey{display:inline-block;-webkit-border-radius:4px;border-radius:4px;border:1px solid #35495e;color:#35495e;text-decoration:none;padding:10px 30px;margin-left:15px}.button--grey:hover{color:#fff;background-color:#35495e}</style><style data-vue-ssr-id="0302a88c:0">.topics-container .header{margin-top:15px;padding:10px;background-color:#f6f6f6;-webkit-border-radius:3px 3px 0 0;border-radius:3px 3px 0 0}.topics-container .header .el-tabs .el-tabs__header{margin:0}</style><style data-vue-ssr-id="fbd963e6:0"></style><style data-vue-ssr-id="03ebe74a:0">#sidebar .box-card[data-v-33b2654c]{margin-bottom:15px}#sidebar .box-card .user_avatar[data-v-33b2654c]{vertical-align:middle;margin-right:10px}#sidebar .box-card .user_avatar img[data-v-33b2654c]{width:48px;height:48px;-webkit-border-radius:3px;border-radius:3px}#sidebar .box-card .user_name[data-v-33b2654c]{font-size:16px;max-width:120px;display:inline-block;vertical-align:middle}#sidebar .box-card .board[data-v-33b2654c]{margin-top:10px;width:80%}#sidebar .box-card .signature[data-v-33b2654c]{font-style:italic;font-size:14px}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3b8070;opacity:0"></div><div id="__layout"><div><section class="topics-container container"><div class="navbar" data-v-86417824><div class="navbar-inner" data-v-86417824><div class="navbar-container" data-v-86417824><ul role="menubar" class="el-menu el-menu--horizontal" data-v-86417824><li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824><a href="/nuxt-blog/" class="nuxt-link-exact-active nuxt-link-active" data-v-86417824>首页</a><li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824><a href="/nuxt-blog/my/messages" data-v-86417824>未读信息</a><li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824>新手入门<li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824>API<li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824>关于<li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824>设置<li role="menuitem" tabindex="-1" class="el-menu-item" style="border-bottom-color:transparent" data-v-86417824><span data-v-86417824>登录</span></ul></div></div></div><div class="clearfix" id="main"><aside id="sidebar" data-v-33b2654c><div class="el-card box-card" data-v-33b2654c><div class="el-card__header"><div class="box-card-header" data-v-33b2654c><span data-v-33b2654c>个人信息</span></div></div><div class="el-card__body"><div class="box-card-content" data-v-33b2654c><div class="box-card-content-header" data-v-33b2654c><a href="javascript:;" class="user_avatar" data-v-33b2654c><img data-v-33b2654c></a><span class="user_name" data-v-33b2654c></span></div><div class="board" data-v-33b2654c><span data-v-33b2654c>积分：</span></div><div class="bottom" data-v-33b2654c><span class="signature" data-v-33b2654c>“ 这家伙很懒，什么个性签名都没有留下。 ”</span></div></div></div></div><div class="el-card box-card" data-v-33b2654c><!----><div class="el-card__body"><div class="box-card-content" data-v-33b2654c><button class="el-button el-button--success el-button--small" type="button" data-v-33b2654c><!----><!----><span>发布话题</span></button></div></div></div></aside><div id="content"><header class="header"><div class="el-tabs el-tabs--top"><div class="el-tabs__header is-top"><div class="el-tabs__nav-wrap is-top"><div class="el-tabs__nav-scroll"><div class="el-tabs__nav" style="transform:translateX(0)" role="tablist"><div class="el-tabs__active-bar is-top"></div></div></div></div></div><div class="el-tabs__content"><div class="el-tab-pane" style="display:none" role="tabpanel" aria-hidden="true" id="pane-null" aria-labelledby="tab-null"></div><div class="el-tab-pane" style="display:none" role="tabpanel" aria-hidden="true" id="pane-good" aria-labelledby="tab-good"></div><div class="el-tab-pane" style="display:none" role="tabpanel" aria-hidden="true" id="pane-share" aria-labelledby="tab-share"></div><div class="el-tab-pane" style="display:none" role="tabpanel" aria-hidden="true" id="pane-ask" aria-labelledby="tab-ask"></div><div class="el-tab-pane" style="display:none" role="tabpanel" aria-hidden="true" id="pane-job" aria-labelledby="tab-job"></div></div></div></header><div class="table-list"><div class="el-table el-table--fit el-table--enable-row-hover el-table--enable-row-transition" style="width:100%"><div class="hidden-columns"><div></div><div></div><div></div><div></div><div></div><div></div></div><div class="el-table__header-wrapper"><table cellspacing="0" cellpadding="0" border="0" class="el-table__header"><colgroup><thead><tr></thead></table></div><div class="el-table__body-wrapper is-scrolling-none"><table cellspacing="0" cellpadding="0" border="0" class="el-table__body"><colgroup><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"></tr><!----></table><!----><!----></div><!----><!----><!----><!----><div class="el-table__column-resize-proxy" style="display:none"></div></div><div class="pagination"><div class="el-pagination"><span class="el-pagination__total">共 1000 条</span><button class="btn-prev disabled" type="button"><i class="el-icon el-icon-arrow-left"></i></button><ul class="el-pager"><li class="number active">1</li><!----><li class="number">2<li class="number">3<li class="number">4<li class="number">5<li class="number">6<li class="el-icon more btn-quicknext el-icon-more"><li class="number">100</ul><button class="btn-next" type="button"><i class="el-icon el-icon-arrow-right"></i></button><span class="el-pagination__jump">前往<div class="el-input el-pagination__editor is-in-pagination" value="1"><!----><input autocomplete="off" autocomplete="off" class="el-input__inner" type="number" rows="2" max="100" min="1" validateevent="true" value="1"><!----><!----><!----></div>页</span><button class="el-button jump-page-btn el-button--primary el-button--small" type="button"><!----><!----><span>跳转</span></button></div></div></div></div></div></section></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{}],error:null,state:{topic:{topic:{},loading:!1},topics:{topics:[{id:"5aae1cc8f5dfc27d7ad98909",author_id:"4efc278525fa69ac69000013",tab:"share",content:"> 更新：公测版本已经上线，请访问 http://egg.cnodejs.org/ ，如遇到任何问题，请提交issue https://github.com/cnodejs/egg-cnode/issues ，谢谢各位。\r\n\r\n在近期，经过社区的小伙伴们的一起努力下，我们基于 Egg.js 将 nodeclub 进行了重写，重写后的代码仓库位于 https://github.com/cnodejs/egg-cnode 。\r\n\r\n原版的 nodeclub 是 2012 年左右，在淘宝实习的某个同学实现的，当时的情况下，几乎没有多少人有过 Node.js 开发真实项目的经验，因此，该项目也存在诸多稚嫩之处，曾经也被 ITeye 的大佬批判过。\r\n\r\n后来在 alsotang、题叶等人的维护下，CNode 经历过一次较大的重构，但那次重构没有对原来的项目进行根本性的改动，重点是用户体验层面的改动。因此 nodeclub 依然保持着比较古老的方式，express + ejs + mongoose 等。原项目缺乏一些工程性的问题：\r\n\r\n1. 基于 Callback 回调的风格，在维护上较为困难。\r\n2. 没有健壮的进程守护机制，纯粹依靠 PM2 。\r\n3. 目前该项目运行时也是单机模式，没有更好的可用性。\r\n\r\n本次我们基于 ES 8、Egg 框架，在不改写业务逻辑，不改写 UI 、交互的前提下，对该项目完成了重写。重写之后的 egg-cnode 具有更好的特性，尤其是在可维护性上，有极大程度上的改进，在测试覆盖率方面，以更少的代码量实现了更高的覆盖率。重写过程历时 3 个礼拜，贡献人数 10 人，以社区协作的形式完成。\r\n\r\n我们将在稍后的一个时间将新的版本进行上线测试，也欢迎大家关注我们新的代码仓库。最后感谢：@sinchang、@thonatos、@lqs469 等人参与的贡献。欢迎大家继续关注我们的项目。",title:"【公测中】基于 Egg 的 CNode 社区",last_reply_at:"2018-04-02T16:30:46.203Z",good:!1,top:!0,reply_count:71,visit_count:5974,create_at:"2018-03-18",author:{loginname:"JacksonTian",avatar_url:"https://avatars3.githubusercontent.com/u/327019?v=4&s=120"}},{id:"5abda42674fe2526d62220d4",author_id:"4efc278525fa69ac69000013",tab:"share",content:"RT。",title:"请不要再发薅羊毛帖子",last_reply_at:"2018-04-02T08:53:07.607Z",good:!1,top:!0,reply_count:9,visit_count:1244,create_at:"2018-03-30",author:{loginname:"JacksonTian",avatar_url:"https://avatars3.githubusercontent.com/u/327019?v=4&s=120"}},{id:"5ab34443e7b166bb7b9ecd06",author_id:"596a2b5edb0b6aec18a28569",tab:"share",content:"加入cnodejs社区也快1年了，没对社区做过什么贡献，看到社区要公测，刚好自己在公司使用node.js做自动化测试。\r\n这次我要对社区贡献一套UI自动化代码，别人如果想自己搭建一套社区的话，可以直接运行这套UI自动化代码来检查UI功能。\r\n平时工作时间比较忙，所以本周日我计划要做如下的事情，\r\n为了让大家都能看懂我的代码，我会使用行为驱动测试的方式来写代码，完成之后的代码大致如下：\r\n![image.png](//dn-cnode.qbox.me/FpAr57XACJfit4rzN4sa2BBulYUj)\r\n可以通过查阅文字描述了解测试的功能点。\r\n\r\n现在我想拉个微信群，如果各位有兴趣，我们可以一起来做。不会写代码也没有关系，可以帮助我们来写测试用例，或者给我们写的测试用例提建议。\r\n![微信图片_20180322133956.png](//dn-cnode.qbox.me/FlVUhc1vFM8HAnb0jH1hRHfT6Nu5)",title:"为社区做贡献，帮社区写自动化测试代码",last_reply_at:"2018-03-29T08:45:54.750Z",good:!1,top:!0,reply_count:25,visit_count:2601,create_at:"2018-03-22",author:{loginname:"imzengyang",avatar_url:"https://avatars1.githubusercontent.com/u/22312483?v=4&s=120"}},{id:"5ac2f0ae96f344940fbbaca6",author_id:"5a9d2f0989a57ad544fa4279",tab:"share",content:"koa 框架是基于 Node.js 下一代的 web server 框架, 舍弃了回调写法, 提高了错误处理效率, 而且其不绑定任何中间件, 核心代码只提供优雅轻量的函数库.\r\n平时经常使用到 koa 框架, 所以希望通过阅读源码学习其思想, 本文是基于 koa2 的源码进行分析.\r\n## koa 整体架构\r\nkoa 框架的源码结构非常简单, 在 lib 文件夹下, 只有 4 个文件, 分别是 application.js, context.js, request.js, response.js.\r\n而 application.js 是 koa 框架的入口文件, context.js 的作用是创建网络请求的上下文对象, request.js 是用于包装 koa 的 request 对象的, response.js\r\n则是用于包装 koa 的 response 对象的. 我们这里使用 koa 框架建立一个简单的 node 服务, 以此来逐步了解 koa 内部机理.\r\n```\r\nconst koa = require('koa');\r\n\r\nconst app = new koa();\r\n\r\napp.use(async (ctx, next) {\r\n  ctx.body = 'Hello World';\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n上面的代码, 先生成了一个 koa 对象, 然后通过使用 use 函数往 server 中添加中间件函数, 最后使用 listen 函数进行对 3000 端口的监听.\r\n## koa 源码剖析\r\n由上面的简单代码, 我们会有几个疑问: koa 对象中包含了些什么属性与方法? use 函数对于中间件函数的处理是怎么样的? listen 函数做了什么?\r\n因此我们先来看一下 application.js 的源码:\r\n### application.js\r\napplication.js 暴露了一个 Application 类供我们使用, 也即是说, 我们 new 一个 koa 对象实质上就是新建一个 Application 的实例对象. 而 Application 类是继承\r\n于 EventEmitter (Node.js events 模块)的, 所以我们在 koa 实例对象上可以使用 on, emit 等方法进行事件监听.\r\n#### 生成 application 对象\r\n```\r\nconstructor() {\r\n  super(); // 因为继承于 EventEmitter, 这里需要调用 super\r\n\r\n  this.proxy = false; // 代理设置\r\n  this.middleware = [];\r\n  this.subdomainOffset = 2; // 子域名偏移设置\r\n  this.env = process.env.NODE_ENV || 'development'; // node 环境变量\r\n  this.context = Object.create(context);\r\n  this.request = Object.create(request);\r\n  this.response = Object.create(response);\r\n}\r\n```\r\n可以看到在 constructor 函数中, 实例对象会初始化几个重要的属性, proxy 属性是代理设置, middleware 属性是中间件数组, 用于存储中间件函数的, subdomainOffset 属性是子域名偏移量\r\n设置, env 属性保存 node 的环境变量 NODE_ENV 值, context, requets, response 则是 koa 自身的包装的 context 对象, request 对象, response 对象. 这里特别讲解一下 proxy 属性与\r\nsubdomainOffset 属性. proxy 属性值是 true 或者 false, 它的作用在于是否获取真正的客户端 ip 地址(详细请看附录的第一点). subdomainOffset 属性会改变获取 subdomain 时返回数组的值,\r\n比如 test.page.example.com 域名, 如果设置 subdomainOffset 为 2, 那么返回的数组值为 [\"page\", \"test\"], 如果设置为 3, 那么返回数组值为 [\"test\"].\r\n#### use 与中间件\r\nuse 函数内部仅仅是对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise), 如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.\r\n所以, 所谓中间件函数的串联其实就是通过数组来逐个执行的, 至于 koa 是怎么利用 koa-compose 建立起核心的中间件机制的, 这里按下不表, 详细请阅读本人的 [理解 koa 中间件机制](http://zhangxiang958.github.io/2018/03/16/%E7%90%86%E8%A7%A3%20Koa%20%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/) 博文.\r\n#### listen 原理\r\nlisten 函数的原理其实很简单, 它实际上是一个缩写的函数, 它本质上就是在内部通过 Node 原生的 http 模块建立起一个 http server, 而这个 http server 的回调函数使用的是 koa 中的 callback 函数.\r\n```\r\nlisten(...args) {\r\n  debug('listen');\r\n  const server = http.createServer(this.callback());\r\n  return server.listen(...args);\r\n}\r\n```\r\n下面就来讲解一下核心的 callback 函数.\r\n```\r\ncallback() {\r\n  const fn = compose(this.middleware);  // 使用 compose 建立中间件机制, 详情请看 http://zhangxiang958.github.io/2018/03/16/%E7%90%86%E8%A7%A3%20Koa%20%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/\r\n\r\n  if (!this.listeners('error').length) this.on('error', this.onerror);  // 如果没有对 error 事件进行监听, 那么绑定 error 事件监听处理\r\n\r\n  // handleRequest 函数相当于 http.creatServer 的回调函数, 有 req, res 两个参数, 代表原生的 request, response 对象.\r\n  const handleRequest = (req, res) => {\r\n    const ctx = this.createContext(req, res); // 每次接受一个新的请求就是生成一次全新的 context\r\n    return this.handleRequest(ctx, fn);\r\n  };\r\n\r\n  return handleRequest;\r\n}\r\n\r\nhandleRequest(ctx, fnMiddleware) {\r\n  const res = ctx.res;\r\n  res.statusCode = 404;\r\n  const onerror = err => ctx.onerror(err); // 错误处理\r\n  const handleResponse = () => respond(ctx); // 响应处理\r\n  onFinished(res, onerror); // 为 res 对象添加错误处理响应, 当 res 响应结束时, 执行 context 中的 onerror 函数(这里需要注意区分 context 与 koa 实例中的 onerror)\r\n  return fnMiddleware(ctx).then(handleResponse).catch(onerror); // 执行中间件数组所有函数, 并结束时调用 respond 函数\r\n}\r\n```\r\n对于 this.createContext 函数, 它的用于就是生成一个新的 context 对象并建立 koa 中 context, requets, response 属性之间与原生 http 对象的关系的.而 handleRequest 函数只是负责执行\r\n中间件所有的函数, 并在中间件函数执行结束的时候调用 respond.\r\n对于在 koa 中的 context 对象, request 对象, response 对象与 http 模块原生的 req 与 res 之间的关系我并不打算陈列代码, 下面我以图解的形式来帮助阅读:\r\n![](http://ofsur12wi.bkt.clouddn.com/applicaton.png)\r\n#### 对请求的响应处理 respond\r\n对于 respond 函数, 其核心就是根据不同类型的数据对 http 的响应头部与响应体 body 做对应的处理.\r\n```\r\nfunction respond(ctx) {\r\n  // allow bypassing koa\r\n  if (false === ctx.respond) return;\r\n\r\n  const res = ctx.res;\r\n  // writable 是原生的 response 对象的 writeable 属性, 检查是否是可写流\r\n  if (!ctx.writable) return;\r\n\r\n  let body = ctx.body;\r\n  const code = ctx.status;\r\n\r\n  // ignore body\r\n  // 如果响应的 statusCode 是属于 body 为空的类型, 例如 204, 205, 304, 将 body 置为 null\r\n  if (statuses.empty[code]) {\r\n    // strip headers\r\n    ctx.body = null;\r\n    return res.end();\r\n  }\r\n\r\n  // 如果是 HEAD 方法\r\n  if ('HEAD' == ctx.method) {\r\n    // headersSent 属性 Node 原生的 response 对象上的, 用于检查 http 响应头部是否已经被发送\r\n    // 如果头部未被发送, 那么添加 length 头部\r\n    if (!res.headersSent && isJSON(body)) {\r\n      ctx.length = Buffer.byteLength(JSON.stringify(body));\r\n    }\r\n    return res.end();\r\n  }\r\n\r\n  // status body\r\n  // 如果 body 值为空\r\n  if (null == body) {\r\n    // body 值为 context 中的 message 属性或 code\r\n    body = ctx.message || String(code);\r\n    // 修改头部的 type 与 length 属性\r\n    if (!res.headersSent) {\r\n      ctx.type = 'text';\r\n      ctx.length = Buffer.byteLength(body);\r\n    }\r\n    return res.end(body);\r\n  }\r\n\r\n  // responses\r\n  // 对 body 为 buffer 类型的进行处理\r\n  if (Buffer.isBuffer(body)) return res.end(body);\r\n  // 对 body 为字符串类型的进行处理\r\n  if ('string' == typeof body) return res.end(body);\r\n  // 对 body 为流形式的进行处理\r\n  if (body instanceof Stream) return body.pipe(res);\r\n\r\n  // body: json\r\n  // 对 body 为 json 格式的数据进行处理, 1: 将 body 转化为 json 字符串, 2: 添加 length 头部信息\r\n  body = JSON.stringify(body);\r\n  if (!res.headersSent) {\r\n    ctx.length = Buffer.byteLength(body);\r\n  }\r\n  res.end(body);\r\n}\r\n```\r\n在 respond 函数中, 主要是运用 node http 模块中的响应对象中的 end 方法与 koa context 对象中代理的属性进行最终响应对象的设置.\r\n### request.js\r\n主要是对原生的 http 模块的 requets 对象进行封装, 其实就是对 request 对象某些属性或方法通过重写 getter/setter 函数进行代理, 请看下面的图进行更好的理解:\r\n![request](http://ofsur12wi.bkt.clouddn.com/reuqest.png)\r\n#### 内容协商\r\n我们可以看到 request 中有很多 accept 相关的方法, 我们来看看 accept 相关的内容协商的知识:\r\n所谓内容协商, 就是客户端向服务端请求文件, 返回符合某些标准的文件, 而除了服务端将所有版本的文件全部返回由\r\n客户端来决定使用哪个版本这种比较浪费网络资源的方法之外, 我们还可以使用通过请求/响应头部进行交流并返回合适\r\n版本的方法.\r\n\r\n| 请求头字段 | 解释 | 对应响应头 | \r\n| - | :-: | -: | \r\n| Accept | 告诉服务端可以接收的类型(text/html, application/json 等) | Content-Type | \r\n| Accept-charset | 告诉服务端可以接收的字符集类型(utf8, GBK 等) | Content-Type |\r\n| Accept-Encoding | 告诉服务端可以接收的压缩类型(gzip, deflate 等) | Content-Encoding | \r\n| Accept-Language | 告诉服务端可以接受的语言类型(zh-CN, en 等) | Content-Language |\r\n\r\n使用上面的头部字段就可以达到请求合适的文档类型.而对于客户端与服务端之间可能有多个实体, 比如 CDN, 缓存服务\r\n器等等, 万一中间实体缓存了错误的文件版本, 那么后果就是客户端有可能无法正确地解析该文件.所以需要 vary 响应\r\n头部字段, vary 字段的值类似于这样: vary: user-agent, location. vary 字段是告诉中间实体如何正确判断有效的\r\n缓存文件版本, 比如像上面的值, 那就是利用请求的 user-agent, location 两个头部的字段生成的 hash, 如果再有请\r\n求过来并且请求的 ua 与 location 头部字段生成的 hash 有缓存, 那么就返回对应的缓存文件.\r\n### response.js\r\n同样的, response 也是对 http 模块的 response 对象进行封装, 通过对 response 对象的某些属性或方法通过重写 getter/setter 函数进行代理, 请看下面的图帮助理解:\r\n![response](http://ofsur12wi.bkt.clouddn.com/koaresponse.png)\r\n\r\n#### Content-disposition\r\n在 response 对象的 attachment 方法中, 我们可以看到对 HTTP 头部的 Content-disposition 字段进行了处理, 那么究竟 Content-disposition 字段是做什么用的?\r\nContent-disposition 是用于说明这个返回的信息是以什么形式展示的, 例如如果值为 inline, 那么就是以网页的一部分或者整个页面展示, 如果是 attachment 的话, 就是以下载附件的\r\n形式展示:\r\n```\r\nContent-Disposition: inline; // 网页一部分或者整个网页展示\r\nContent-Disposition: attachment; // 下载网页附件的形式\r\nContent-Disposition: attachment, filename=\"xxx.ext\"; // 还可以使用 filename 来指定文件名\r\n```\r\n当然, 在 Content-Type 为 multipart/form-data 格式中, Content-Disposition 也会发挥作用, 用于定义表单的键名:\r\n```\r\nContent-Type: multipart/form; boundry=\"boundry\"\r\n\r\n--boundry\r\nContent-Disposition: form-data; name=\"field1\"\r\n\r\nvalue\r\n--boundry\r\nContent-Disposition: form-data; name=\"field2\"\r\n\r\nvalue\r\n```\r\n#### 缓存协商\r\n在 request 中使用 fresh 字段来判断这个请求需要的内容是否是最新的, 其原理也就是我们熟知的 http 缓存机制, 内部通过 fresh 这个库, 判断请求头部中的 if-modify-since 与\r\nif-match-since 对比于响应头部中的 last-Modified 字段与 ETag 字段.当然, 在检查这两个字段之前, 还需要检查一下请求头部的 Cache-Control 头部, 如果 Cache-Control 头部\r\n是 no-cache, 那么就代表请求信息必须是最新的, 如果不是 no-cache, 接着就需要判断上面说的两个字段.而 last-modified 与 ETag 的检查有没有优先顺序呢? 答案是有的.\r\nkoa 中先检查 ETag 有没有过期, 手段是通过检查 if-match-since 字段与 Etag 字段是否相同, 然后会检查 last-modified 有没有过期, 手段是通过检查 if-modify-since 与 last-modified\r\n的日期是不是 last-modified 日期时间戳小于 if-modified-since 日期时间戳, 如果是那么说明内容是新鲜的, 如果不是说明内容是旧的.\r\n\r\n### context.js\r\n分析了上面的 request 与 response, context 的分析更为简单了, context 的核心就是通过 delegates 这一个库, 将 request, response 对象上的属性方法代理到 context 对象上.\r\n也就是说例如 this.ctx.headersSent 相当于 this.response.headersSent. request 对象与 response 对象的所有方法与属性都能在 ctx 对象上找到. 这里我们来看一下 delegates 库\r\n的属性代理函数的片段, 借此理解一下 context 是如何代理 request 与 response 上的属性与方法的:\r\n```\r\ndelegate(proto, 'response')\r\n  .getter('headerSent');\r\n```\r\n```\r\nDelegator.prototype.getter = function(name){\r\n  // this.proto 指向原型, 这里的 proto 就是上面的 proto, 也就是说 context 对象\r\n  var proto = this.proto;\r\n  // target 是指 'response' 字符串\r\n  var target = this.target;\r\n  // 将 name 加入到 delegator 实例对象的 getters 数组中\r\n  this.getters.push(name);\r\n  // 调用原生的 __defineGetter__ 方法进行 getter 代理, 那么 proto[name] 就相当于 proto[target][name]\r\n  // 而 context.response 就相当于 response 对象\r\n  // 由此实现属性代理\r\n  proto.__defineGetter__(name, function(){\r\n    return this[target][name];\r\n  });\r\n\r\n  return this;\r\n};\r\n```\r\n## 错误处理\r\n在 koa 中, 错误处理分为在 application.js 中的 onerror 处理函数与在 context.js 中的 onerror 处理函数.这两者绑定的位置是不一样的, context 的 onerror 函数是绑定在\r\n中间函数数组生成的 Promise 的 catch 中与 res 对象的 onFinished 函数的回调的, 这里的意图显而易见, 就是为了处理请求或响应中出现的 error 事件的.\r\n而 application.js 中的 onerror 函数是绑定在 koa 实例对象上的, 它监听的是整个对象的 error 事件.\r\n### context 中的错误处理\r\n```\r\nonerror(err) {\r\n  // don't do anything if there is no error.\r\n  // this allows you to pass `this.onerror`\r\n  // to node-style callbacks.\r\n  // 没有错误则忽略, 不执行下面的逻辑\r\n  if (null == err) return;\r\n  // 将错误转化为 Error 实例\r\n  if (!(err instanceof Error)) err = new Error(util.format('non-error thrown: %j', err));\r\n\r\n  let headerSent = false;\r\n  if (this.headerSent || !this.writable) {\r\n    headerSent = err.headerSent = true;\r\n  }\r\n\r\n  // delegate\r\n  // 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行\r\n  this.app.emit('error', err, this);\r\n\r\n  // nothing we can do here other\r\n  // than delegate to the app-level\r\n  // handler and log.\r\n  // 如果响应头部已经发送(或者 socket 不可写), 那么退出函数\r\n  if (headerSent) {\r\n    return;\r\n  }\r\n  // 获取 http 原生 res 对象\r\n  const { res } = this;\r\n  \r\n  // first unset all headers\r\n  // 根据文档 res.getHeaderNames 函数是 7.7.0 版本后添加的, 这里为了兼容做了一个判断\r\n  // 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置\r\n  if (typeof res.getHeaderNames === 'function') {\r\n    res.getHeaderNames().forEach(name => res.removeHeader(name));\r\n  } else {\r\n    res._headers = {}; // Node < 7.7\r\n  }\r\n\r\n  // then set those specified\r\n  this.set(err.headers);\r\n\r\n  // force text/plain\r\n  // 出错后响应类型为 text/plain\r\n  this.type = 'text';\r\n\r\n  // ENOENT support\r\n  // 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404\r\n  if ('ENOENT' == err.code) err.status = 404;\r\n\r\n  // default to 500\r\n  // 默认设置状态码为 500\r\n  if ('number' != typeof err.status || !statuses[err.status]) err.status = 500;\r\n\r\n  // respond\r\n  const code = statuses[err.status];\r\n  const msg = err.expose ? err.message : code;\r\n  // 设置响应状态码\r\n  this.status = err.status;\r\n  // 设置响应 body 长度\r\n  this.length = Buffer.byteLength(msg);\r\n  // 返回 message\r\n  this.res.end(msg);\r\n}\r\n```\r\n### application 中的错误处理\r\napplication 中的错误处理是对 koa 实例对象中例如函数执行出错等等内部错误进行处理.\r\n```\r\nonerror(err) {\r\n  // 判断 err 是否是 Error 实例\r\n  assert(err instanceof Error, `non-error thrown: ${err}`);\r\n  // 忽略 404 错误\r\n  if (404 == err.status || err.expose) return;\r\n  // 如果有静默设置, 则忽略\r\n  if (this.silent) return;\r\n  // 打印出出错堆栈\r\n  const msg = err.stack || err.toString();\r\n  console.error();\r\n  console.error(msg.replace(/^/gm, '  '));\r\n  console.error();\r\n}\r\n```\r\n这个函数的主要作用就是处理出错函数的堆栈打印, 方便我们进行问题定位.\r\n## 附录\r\n### 1. koa 中 proxy 属性真正用途是什么?\r\n要知道, 我们在实际运用中, 可能会使用很多的代理服务器, 包括我们常见的正向代理与反向代理, 虽然代理的用处很大, 但是无法避免地我们有时需要知晓真正的客户端的请求 ip,\r\n而其实实际上, 服务器并不知道真正的客户端请求 ip, 即使你使用 socket.remoteAddrss 属性来查看, 因为这个请求是代理服务器转发给服务器的, 幸好代理服务器例如 nginx 提供了一个\r\nHTTP 头部来记录每次代理服务器的源 IP 地址, 也就是 X-Forwarded-For 头部.形式如下:\r\n```\r\nX-Forwarded-For: 192.168.210.13, 210.112.40.13, 43.56.210.10\r\n```\r\n如果一个请求跳转了很多代理服务器, 那么 X-Forwarded-For 头部的 ip 地址就会越多, 第一个就是原始的客户端请求 ip, 第二个就是第一个代理服务器 ip, 以此类推.\r\n当然, X-Forwarded-For 并不完全可信, 因为中间的代理服务器可能会\"使坏\"更改某些 IP. 而 koa 中 proxy 属性的设置就是如果使用 true, 那么就是使用 X-Forwarded-For 头部的第一个\r\nip 地址, 如果使用 false, 则使用 server 中的 socket.remoteAddress 属性值.\r\n除了 X-Forwarded-For 之外, proxy 还会影响 X-Forwarded-proto 的使用, 和 X-Forwarded-For 一样, X-Forwarded-proto 记录最开始的请求连接使用的协议类型(HTTP/HTTPS), 因为客户端与\r\n服务端之间可能会存在很多层代理服务器, 而代理服务器与服务端之间可能只是使用 HTTP 协议, 并没有使用 HTTPS, 所以 proxy 属性为 true 的话, koa 的 protocol 属性会去取 X-Forwarded-proto 头部\r\n的值(koa 中 protocol 属性会先使用 tlsSocket.encrypted 属性来判断是否是 https 协议, 如果是则直接返回 'https').\r\n### 2. javascript 中的 ~ 运算符\r\n~ 运算符是一元运算符, 它的运算逻辑是如下: 例如计算 ~1\r\n```\r\n1. 将十进制的 1 转化为二进制的 0001\r\n2. 先对 0001 按位取反: 1110\r\n3. 然后我们知道最高位为 1, 所以数字为负数, 然后将除去最高位剩下的三位数字再按位取反得到 001\r\n4. 然后再向 001 加 1 即 001 + 001 得到 010, 转为十进制为数字 2\r\n5. 再加上我们之前最高位为 1, 所以最后数字为负数即 -2\r\n6. 所以 ~1 === -2\r\n```\r\n用简略的表达式来说明就是 ~ X = -(X + 1).而我们可以看到在 koa 中, length 返回的结果使用了 ~~length 这样的形式, 两次二进制否运算, 这样的目的是为了值得安全输出, 如果 ~ 运算符后面的值\r\n是 NaN, null, 空字符串, 空数组, 非数字字符串的话, 返回值为 -1, 而对于小数, ~ 运算符会向下取整.其实对于小数, ~ 运算会选择忽略小数部分, 对于非整数的值会先执行 Number 类型转化.\r\n所以两次二进制否运算 ~~, 可以使小数向下取整, 让非整数值输出为 0(~-1 === 0).\r\n\r\n### 3. Buffer.byteLength 计算长度\r\n细心阅读源码会发现, 在 koa 中设置响应的 length 头部信息, 并不是使用字符串的 length 属性来设置的, 而是通过 Buffer.byteLength 方法来计算得到的. 为什么要这么做呢?\r\nHTTP Content-length 头部的数值其实是字节数而不是字符数, 对于汉字来说, utf-8 编码模式下一个汉字字符需要 3 个字节, 所以不能使用字符串的 length 属性来赋值 Content-Length 头部.\r\n\r\n### 4. Restful 中的幂等性\r\n我们可以在 request 对象中找到, 有 idempotent 属性, 它用于判断请求方法 verb 是不是幂等的. 所谓幂等性, 就是无论这个相同的请求请求多少次, 得到的数据结果是一样的. 而在 HTTP 的方法中,\r\nGET, HEAD, PUT, DELETE, TRACK, OPTIONS 请求都是幂等的. 对于 POST 与 PATCH 方法则是不幂等的.\r\n这里特别讲解一下 PUT 的含义, PUT 的定义是 Replace(create or update), 如果存在那么就替换, 如果不存在那么就新增数据.",title:"Koa 源码解析",last_reply_at:"2018-04-03T03:10:38.331Z",good:!1,top:!1,reply_count:0,visit_count:20,create_at:"2018-04-03",author:{loginname:"zhangxiang958",avatar_url:"https://avatars1.githubusercontent.com/u/13307374?v=4&s=120"}},{id:"5ac2ebd10ab0448f0fe3f821",author_id:"5a6a011bafa0a121784a8fd1",tab:"ask",content:"![koa.png](//dn-cnode.qbox.me/FgeaNyEG9ZJdUDsZYFKZbywTlewu)\r\n为什么JSON的中文数据乱码。",title:"koa的响应的的JSON数据乱码",last_reply_at:"2018-04-03T02:49:53.954Z",good:!1,top:!1,reply_count:0,visit_count:53,create_at:"2018-04-03",author:{loginname:"TangJinJian",avatar_url:"https://avatars3.githubusercontent.com/u/30863349?v=4&s=120"}},{id:"5ac2ddea37f5d1510f57c84f",author_id:"5a12c1d2476ea1170b73398f",tab:"share",content:"原文 https://juejin.im/post/5ac24f976fb9a028d0439cbb\r\nkoa2 源码分析\r\n最近想做一个关于NodeJS 服务端相关的总结，思前想后觉得可以从源码分析作为切入点。于是首先便选择了koa2.\r\n注：由于书写习惯原因 ，下文中所有出现koa的字眼 皆指的是koa2.x版本。如果是1.x版本则用koa1.x标明。\r\n首先进入koa2 的文件目录 ，我们可以看到只有只有四个文件 https://github.com/koajs/koa/tree/master/lib. 分别是\r\napplication.js\r\ncontext.js\r\nrequest.js\r\nresponse.js\r\napplication.js 是项目的入口文件，对外输出一个class ,这个class 就是koa 实例。 源码如下：\r\nmodule.exports = class Application extends Emitter {\r\n  /**\r\n   * Initialize a new `Application`.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    this.proxy = false;\r\n    this.middleware = [];\r\n    this.subdomainOffset = 2;\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);\r\n  }\r\n  ...\r\n先从外层剖析\r\n首先我们先看看koa2的正常使用逻辑。 以下是一个有koa2脚手架生成的一个初始化项目\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n...\r\n\r\n// middlewares\r\napp.use(bodyparser({\r\n  enableTypes:['json', 'form', 'text']\r\n}))\r\napp.use(json())\r\napp.use(logger())\r\napp.use(require('koa-static')(__dirname + '/public'))\r\n\r\napp.use(views(__dirname + '/views', {\r\n  extension: 'pug'\r\n}))\r\n\r\n// logger\r\napp.use(async (ctx, next) => {\r\n  const start = new Date()\r\n  await next()\r\n  const ms = new Date() - start\r\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\r\n})\r\n\r\n// routes\r\napp.use(index.routes(), index.allowedMethods())\r\napp.use(users.routes(), users.allowedMethods())\r\n\r\n// error-handling\r\napp.on('error', (err, ctx) => {\r\n  console.error('server error', err, ctx)\r\n});\r\n\r\n\r\nvar http = require('http');\r\nvar server = http.createServer(app.callback());\r\nserver.listen(port);\r\n可以看到koa的核心非常简要。就是初始化一个实例 在实例中传入一系列中间件。 然后我们创建一个http服务器， 将koa实例下的回调函数传入其中。 即app.callback(); 然后就可以开始监听服务了。 先对比一下原生http 服务的创建\r\nconst http = require('http')\r\nconst server = http.createServer((req, res) => {\r\n})\r\nserver.listen(3000, () => {\r\n  console.log('server listening at 3000 port!')\r\n})\r\n这里我们可以关注到看两点\r\n1 koa 服务主要是在做中间件处理\r\n2 koa 对原生http 创建方法的回调做了处理,原生是 (req,res) =>{ }, koa 对齐做了封装 封装成了 koa.callback()。\r\n进入application.js 查看koa实例\r\n构造\r\n我们重点关注中间件处理和对http 的 req res 请求返回流的处理。 下面来逐一分析 application 的源码\r\nmodule.exports = class Application extends Emitter {\r\n  /**\r\n   * Initialize a new `Application`.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    this.proxy = false;// 是否信任 proxy header 参数，默认为 false\r\n    this.middleware = []; //保存中间件函数的数组\r\n    this.subdomainOffset = 2;// 不懂\r\n    this.env = process.env.NODE_ENV || 'development';// 环境变量\r\n    \r\n    // 将 context.js  request.js response.js 分别赋值到该实例下\r\n    this.context = Object.create(context); \r\n    this.request = Object.create(request); \r\n    this.response = Object.create(response);\r\n  }\r\n  ...\r\nlisten 方法\r\nlisten 方法 我们可以看到 listen 是已经封装好了一个 创建http服务的方法 这个方法传入一个 该实例的回调 即 app.callback() ，返回一个监听方法。所以服务 也可以直接通过app.listen(...arg) 启动\r\n/**\r\n   * Shorthand for:\r\n   *\r\n   *    http.createServer(app.callback()).listen(...)\r\n   *\r\n   * @param {Mixed} ...\r\n   * @return {Server}\r\n   * @api public\r\n   */\r\n\r\n  listen(...args) {\r\n    debug('listen');\r\n    const server = http.createServer(this.callback());\r\n    return server.listen(...args);\r\n  }\r\nuse\r\n接下来就是use方法 主要做的事情就是 传入一个中间件方法 将中间件push到this.middleware 数组. this.middleware.push(fn); 其实use 最关键的的就只有这一行代码。\r\n除此之外作者还提醒我们，传入中间件的Fn不要写成generator 函数。 原因是因为 koa2是基于 async await 处理异步。 async 和 await 是ES7 新增的语法 本质是对 generator 函数做的一层封装 。 实现了异步变同步的写法， 更够更清晰的反映出函数控制流。相似功能的库在koa1.x 还有一个co 库 非常有名，实现原理也很简单 主要是两种方式 用thunk 或者 Promise 结合递归都可以实现。 大家感兴趣可以看阮一峰老师的ES6标准 里面就有提到 Generator 函数的异步应用 传送门。\r\n/**\r\n   * Use the given middleware `fn`.\r\n   *\r\n   * Old-style middleware will be converted.\r\n   *\r\n   * @param {Function} fn\r\n   * @return {Application} self\r\n   * @api public\r\n   */\r\n\r\n  use(fn) {\r\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\r\n    if (isGeneratorFunction(fn)) {\r\n      deprecate('Support for generators will be removed in v3. ' +\r\n                'See the documentation for examples of how to convert old middleware ' +\r\n                'https://github.com/koajs/koa/blob/master/docs/migration.md');\r\n      fn = convert(fn);\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);\r\n    return this;\r\n  }\r\n  \r\n\r\n接下来我们就看到了 最关键的callback 方法了. callback 对node原生http返回一个handler callback。 第一行代码 将存放中间件函数的数组 this.middleware 通过compose 函数处理得到一个 fn。\r\ncallback 方法\r\n/**\r\n  * Return a request handler callback\r\n  * for node's native http server.\r\n  *\r\n  * @return {Function}\r\n  * @api public\r\n  */\r\n\r\n callback() {\r\n   const fn = compose(this.middleware);\r\n\r\n   if (!this.listeners('error').length) this.on('error', this.onerror);\r\n\r\n   const handleRequest = (req, res) => {\r\n     const ctx = this.createContext(req, res);\r\n     return this.handleRequest(ctx, fn);\r\n   };\r\n\r\n   return handleRequest;\r\n }\r\ncompose 函数\r\ncompose 函数前端用过 redux 的同学肯定都很熟悉。redux 通过compose来处理 中间件 。 原理是 借助数组的 reduce 对数组的参数进行迭代，而我们来看看kos实现compose的方法。感觉扯远了。\r\n// redux 中的compose 函数\r\n\r\nexport default function compose(...funcs) {\r\n  if (funcs.length === 0) {\r\n    return arg => arg\r\n  }\r\n\r\n  if (funcs.length === 1) {\r\n    return funcs[0]\r\n  }\r\n\r\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\r\n}\r\n言归正传，koa 实例中的compose是作为一个包引入的 ， koa-compose 源代码如下\r\n/**\r\n * Compose `middleware` returning\r\n * a fully valid middleware comprised\r\n * of all those which are passed.\r\n *\r\n * @param {Array} middleware\r\n * @return {Function}\r\n * @api public\r\n */\r\n\r\nfunction compose (middleware) {\r\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\r\n  for (const fn of middleware) {\r\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\r\n  }\r\n\r\n  /**\r\n   * @param {Object} context\r\n   * @return {Promise}\r\n   * @api public\r\n   */\r\n\r\n  return function (context, next) {\r\n    // last called middleware #\r\n    let index = -1\r\n    return dispatch(0)\r\n    function dispatch (i) {\r\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\r\n      index = i\r\n      let fn = middleware[i]\r\n      if (i === middleware.length) fn = next\r\n      if (!fn) return Promise.resolve()\r\n      try {\r\n        return Promise.resolve(fn(context, function next () {\r\n          return dispatch(i + 1)\r\n        }))\r\n      } catch (err) {\r\n        return Promise.reject(err)\r\n      }\r\n    }\r\n  }\r\n}\r\n这个compose函数 返回一个函数， 这个函数执行则可以 通过一个递归去遍历执行所有的中间件函数。通过在Promise.resolve(fn)的回调中执行fn 即实现了对异步函数的处理。我们可以关注一下 最初是执行的是 dispatch(0) 也就是this.middleware数组中下标为0的函数，也就是说 最先进入的中间件函数会最先被执行 就像一个执行队列。\r\n执行完成以后 执行next() 到下一步处理。 这个时候我们再看第一行 const fn = compose(this.middleware); 。 fn 实际上是一个待执行所有中间件的方法 。 我们再回顾一下callback()\r\ncallback() {\r\n   const fn = compose(this.middleware);\r\n\r\n   if (!this.listeners('error').length) this.on('error', this.onerror);\r\n\r\n   const handleRequest = (req, res) => {\r\n     const ctx = this.createContext(req, res);\r\n     return this.handleRequest(ctx, fn);\r\n   };\r\n\r\n   return handleRequest;\r\n }\r\n首先 我们取到了 能够一次性执行所有中间件函数的fn . callback 返回一个方法。 这个方法输入 原生创建http函数的 req,res 流 并对其进行封装成一个context 对象。并调用handleRequest 方法返回 handleRequest(ctx,fn) 。\r\n看到这里其实关键步骤就已经很清晰了剩下只关注\r\nkoa 如何将req res 包装到ctx\r\nhandleRequest 如何处理ctx 和 fn\r\ncreateContext方法\r\ncreateContext 将req 和 res 分别挂载到context 对象上。\r\nconst request = context.request = Object.create(this.request);\r\n    const response = context.response = Object.create(this.response);\r\n并对req 上一些关键的属性进行处理和简化 挂载到该对象本身，简化了对这些属性的调用。\r\n/**\r\n   * Initialize a new context.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  createContext(req, res) {\r\n    const context = Object.create(this.context);\r\n    const request = context.request = Object.create(this.request);\r\n    const response = context.response = Object.create(this.response);\r\n    context.app = request.app = response.app = this;\r\n    context.req = request.req = response.req = req;\r\n    context.res = request.res = response.res = res;\r\n    request.ctx = response.ctx = context;\r\n    request.response = response;\r\n    response.request = request;\r\n    context.originalUrl = request.originalUrl = req.url;\r\n    context.cookies = new Cookies(req, res, {\r\n      keys: this.keys,\r\n      secure: request.secure\r\n    });\r\n    request.ip = request.ips[0] || req.socket.remoteAddress || '';\r\n    context.accept = request.accept = accepts(req);\r\n    context.state = {};\r\n    return context;\r\n  }\r\nhandleRequest 方法\r\nhandleRequest 方法直接作为监听成功的调用方法。已经拿到了 包含req res 的ctx 和 可以执行所有 中间件函数的fn. 首先一进来默认设置状态码为404 . 然后分别声明了 成功函数执行完成以后的成功 失败回调方法。这两个方法实际上就是再将ctx 分化成req res . 分别调这两个对象去客户端执行内容返回。 还有三个文件 context.js request.js response.js 分别是封装了一些对ctx req res 操作相关的属性。\r\n/**\r\n  * Handle request in callback.\r\n  *\r\n  * @api private\r\n  */\r\n\r\n handleRequest(ctx, fnMiddleware) {\r\n   const res = ctx.res;\r\n   res.statusCode = 404;\r\n   const onerror = err => ctx.onerror(err);\r\n   const handleResponse = () => respond(ctx);\r\n   onFinished(res, onerror);\r\n   return fnMiddleware(ctx).then(handleResponse).catch(onerror);\r\n }\r\n失败回调执行\r\n/**\r\n   * Default error handler.\r\n   *\r\n   * @param {Error} err\r\n   * @api private\r\n   */\r\n\r\n  onerror(err) {\r\n    assert(err instanceof Error, `non-error thrown: ${err}`);\r\n\r\n    if (404 == err.status || err.expose) return;\r\n    if (this.silent) return;\r\n\r\n    const msg = err.stack || err.toString();\r\n    console.error();\r\n    console.error(msg.replace(/^/gm, '  '));\r\n    console.error();\r\n  }\r\n};\r\n成功回调执行的方法\r\n/**\r\n * Response helper.\r\n */\r\n\r\nfunction respond(ctx) {\r\n  // allow bypassing koa\r\n  if (false === ctx.respond) return;\r\n\r\n  const res = ctx.res;\r\n  if (!ctx.writable) return;\r\n\r\n  let body = ctx.body;\r\n  const code = ctx.status;\r\n\r\n  // ignore body\r\n  if (statuses.empty[code]) {\r\n    // strip headers\r\n    ctx.body = null;\r\n    return res.end();\r\n  }\r\n\r\n  if ('HEAD' == ctx.method) {\r\n    if (!res.headersSent && isJSON(body)) {\r\n      ctx.length = Buffer.byteLength(JSON.stringify(body));\r\n    }\r\n    return res.end();\r\n  }\r\n\r\n  // status body\r\n  if (null == body) {\r\n    body = ctx.message || String(code);\r\n    if (!res.headersSent) {\r\n      ctx.type = 'text';\r\n      ctx.length = Buffer.byteLength(body);\r\n    }\r\n    return res.end(body);\r\n  }\r\n\r\n  // responses\r\n  if (Buffer.isBuffer(body)) return res.end(body);\r\n  if ('string' == typeof body) return res.end(body);\r\n  if (body instanceof Stream) return body.pipe(res);\r\n\r\n  // body: json\r\n  body = JSON.stringify(body);\r\n  if (!res.headersSent) {\r\n    ctx.length = Buffer.byteLength(body);\r\n  }\r\n  res.end(body);\r\n}\r\n讲到这里 其实主要的代码就讲完了。可以看出 koa2 的思想非常简洁。一句话就是由中间件控制所有流程。所以被形象的称为洋葱模型。同时还有一些特色就是 非核心代码都写成了第三方依赖，这样便于生态的发展。 这也是如今很多框架react vue 等的发展的趋势。\r\n最后，我写这个的目的也是为了学习，且深感看源码简单要理解真正的精髓还是很难很难。且学且珍惜吧 哈哈 😉",title:"我们来一步一步分析koa2的源码🙂",last_reply_at:"2018-04-03T02:28:07.063Z",good:!1,top:!1,reply_count:1,visit_count:61,create_at:"2018-04-03",author:{loginname:"yangfan0095",avatar_url:"https://avatars2.githubusercontent.com/u/21197847?v=4&s=120"}},{id:"5ac073b852d7d3a8698a49f4",author_id:"57abe0de476898b472247de2",tab:"share",content:'目前正在翻译中文文档，期待大家的一起参与：\r\n\r\n[typeorm中文文档 ](https://github.com/huanz/typeorm.github.io)\r\n\r\n中文文档地址：[http://typeorm.noonme.com/](http://typeorm.noonme.com/)\r\n\r\n\r\n\r\n[![TypeORM](https://github.com/typeorm/typeorm/raw/master/resources/logo_big.png)](http://typeorm.io/)\r\n\r\nTypeORM是一个[ORM](https://en.wikipedia.org/wiki/Object-relational_mapping)框架，它可以运行在NodeJS、浏览器、Cordova、PhoneGap和Ionic平台上，可以与TypeScript和JavaScript (ES5, ES6, ES7)一起使用。\r\n它的目标是始终支持最新的JavaScript特性并提供额外的特性以帮助你开发任何使用数据库的应用程序 —— 不管是只有几张表的小型应用还是拥有多数据库的大型企业应用。\r\n\r\n不同于现有的所有其他JavaScript ORM框架，TypeORM支持Active Record和Data Mapper模式，这意味着你用最有效的方法编写高质量的、松耦合的、可扩展的、可维护的应用程序。\r\n\r\nTypeORM受到了参考了很多其他优秀ORM的实现, 比如 [Hibernate](http://hibernate.org/orm/), [Doctrine](http://www.doctrine-project.org/) 和 [Entity Framework](https://www.asp.net/entity-framework).\r\n\r\nTypeORM 的一些特性：\r\n- 支持Active Record和Data Mapper（你可以自由选择）\r\n- 实体和列\r\n- 数据库特性列类型\r\n- 实体管理\r\n- 存储库和自定义存储\b库\r\n- 清洁对象关系模型\r\n- 关联（关系）\r\n- 贪婪和延迟关系\r\n- 单向的，双向的和自引用的关系\r\n- 支持多重继承模式\r\n- 级联\r\n- 索引\r\n- 事务\r\n- 迁移和自动迁移\r\n- 连接池\r\n- 复制\r\n- 使用多个数据库连接\r\n- 使用多个数据库类型\r\n- 跨数据库和跨模式查询\r\n- 优雅的语法，灵活而强大的QueryBuilder\r\n- 左联接和内联接\r\n- 准确的分页连接查询\r\n- 查询缓存\r\n- 原始结果流\r\n- 日志\r\n- 监听者和订阅者（钩子）\r\n- 支持闭包表模式\r\n- 在模型或者分离的配置文件中声明模式\r\n- json / xml / yml / env格式的连接配置\r\n- 支持 MySQL / MariaDB / Postgres / SQLite / Microsoft SQL Server / Oracle / WebSQL / sql.js\r\n- 支持 MongoDB NoSQL 数据库\r\n- 在NodeJS / 浏览器 / Ionic / Cordova / Electron平台上工作\r\n- 支持 TypeScript 和 JavaScript\r\n- 产生出高性能、灵活、清洁和可维护的代码\r\n- 遵循所有可能的最佳实践\r\n- 命令行工具\r\n\r\n还有更多...\r\n\r\n使用TypeORM你的模型是这样的：\r\n\r\n```typescript\r\nimport {Entity, PrimaryGeneratedColumn, Column} from "typeorm";\r\n\r\n@Entity()\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    firstName: string;\r\n\r\n    @Column()\r\n    lastName: string;\r\n\r\n    @Column()\r\n    age: number;\r\n\r\n}\r\n```\r\n\r\n你的域逻辑是这样的：\r\n\r\n```typescript\r\nconst user = new User();\r\nuser.firstName = "Timber";\r\nuser.lastName = "Saw";\r\nuser.age = 25;\r\nawait repository.save(user);\r\n\r\nconst allUsers = await repository.find();\r\nconst firstUser = await repository.findOneById(1);\r\nconst timber = await repository.findOne({ firstName: "Timber", lastName: "Saw" });\r\n\r\nawait repository.remove(timber);\r\n```\r\n\r\n或者，你如果你喜欢使用“ActiveRecord”实现，你也可以使用它：\r\n\r\n```typescript\r\nimport {Entity, PrimaryGeneratedColumn, Column, BaseEntity} from "typeorm";\r\n\r\n@Entity()\r\nexport class User extends BaseEntity {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    firstName: string;\r\n\r\n    @Column()\r\n    lastName: string;\r\n\r\n    @Column()\r\n    age: number;\r\n\r\n}\r\n```\r\n\r\n你的域逻辑是这样的：\r\n\r\n```typescript\r\nconst user = new User();\r\nuser.firstName = "Timber";\r\nuser.lastName = "Saw";\r\nuser.age = 25;\r\nawait user.save();\r\n\r\nconst allUsers = await User.find();\r\nconst firstUser = await User.findOneById(1);\r\nconst timber = await User.findOne({ firstName: "Timber", lastName: "Saw" });\r\n\r\nawait timber.remove();\r\n```\r\n\r\n## 请注意\r\n\r\n这个文档可能不是最新的。 \r\n可以去[官网](http://typeorm.io)查看最新的英文文档。\r\n非常欢迎你的贡献。\r\n\r\n## 安装\r\n\r\n1. 安装TypeORM:\r\n\r\n    `npm install typeorm --save`\r\n\r\n2. 需要安装依赖模块 `reflect-metadata` :\r\n\r\n    `npm install reflect-metadata --save`\r\n\r\n    在应用里全局引用一下:\r\n\r\n    * 比如在app.ts的入口处 `require("reflect-metadata")` \r\n\r\n3. 你可能需要安装node类型：\r\n\r\n    `npm install @types/node --save`\r\n\r\n4. 安装数据库驱动:\r\n\r\n    * **MySQL** 或 **MariaDB**\r\n    \r\n        `npm install mysql --save`\r\n    \r\n    * **PostgreSQL**\r\n    \r\n        `npm install pg --save`\r\n    \r\n    * **SQLite**\r\n    \r\n        `npm install sqlite3 --save`\r\n    \r\n    * **Microsoft SQL Server**\r\n    \r\n        `npm install mssql --save`\r\n\r\n    * **sql.js**\r\n\r\n        `npm install sql.js --save`\r\n    \r\n    * **Oracle** (experimental)\r\n    \r\n        `npm install oracledb --save`\r\n    \r\n    可以根据你的数据库选择安装上面的任意一个.\r\n    \r\n    使用oracle驱动需要参考安装说明：[地址](https://github.com/oracle/node-oracledb).\r\n\r\n#### TypeScript配置\r\n\r\n确保你的TypeScript编译器的版本大于**2.3**，并且在`tsconfig.json`开启下面设置:\r\n\r\n```json\r\n"emitDecoratorMetadata": true,\r\n"experimentalDecorators": true,\r\n```\r\n\r\n同时需要开启编译选项里的`lib`下的`es6`或者从`@typings`安装`es6-shim`\r\n\r\n## 快速开始\r\n\r\n开始使用TypeORM的最快方法是使用它的CLI命令生成一个初始项目。\r\n快速开始只有在NodeJS应用程序中使用TypeORM才可以使用。\r\n如果你正在使用其他平台，请看[分步指南](#分步指南)。\r\n\r\n首先全局安装TypeORM：\r\n\r\n```\r\nnpm install typeorm -g\r\n```\r\n\r\n然后转到新项目的目录并运行该命令：\r\n\r\n```\r\ntypeorm init --name MyProject --database mysql\r\n```\r\n\r\n`name`即项目的名称，`database`是你将使用的数据库。数据库可以是下列值之一：`mysql`、`mariadb`、`postgres`、`sqlite`、`mssql`、`oracle`，`websql`、`mongodb`。\r\n\r\n该命令将在`MyProject`目录中生成一个新项目，其中包含以下文件：\r\n\r\n```\r\nMyProject\r\n├── src              // 放你的 TypeScript 代码\r\n│   ├── entity       // 放实体（数据库模型）的目录\r\n│   │   └── User.ts  // 实体的案例\r\n│   ├── migration    // 迁移文件目录\r\n│   └── index.ts     // 应用程序入口\r\n├── .gitignore       // 标准git忽略文件\r\n├── ormconfig.json   // ORM和数据连接配置\r\n├── package.json     // node模块依赖\r\n├── README.md        // 简单的说明文件\r\n└── tsconfig.json    // TypeScript编译配置\r\n```\r\n\r\n> 你也可以在现有的node项目目录执行`typeorm init`，但是一定要小心 - 它可能会覆盖你已经有的一些文件。\r\n\r\n下一步是安装项目依赖\r\n\r\n```\r\ncd MyProject\r\nnpm install\r\n```\r\n\r\n在安装过程中，修改 `ormconfig.json` 文件将自己的数据库连接配置选项放在其中：\r\n\r\n```json\r\n{\r\n   "type": "mysql",\r\n   "host": "localhost",\r\n   "port": 3306,\r\n   "username": "test",\r\n   "password": "test",\r\n   "database": "test",\r\n   "synchronize": true,\r\n   "logging": false,\r\n   "entities": [\r\n      "src/entity/**/*.ts"\r\n   ],\r\n   "migrations": [\r\n      "src/migration/**/*.ts"\r\n   ],\r\n   "subscribers": [\r\n      "src/subscriber/**/*.ts"\r\n   ]\r\n}\r\n```\r\n\r\n通常来说，大多数时候你只需要配置`host`，`username`，`password`，`database` 或者 `port` 选项。\r\n\r\n配置和模块安装都完成之后，就可以运行应用程序了：\r\n\r\n```\r\nnpm start\r\n```\r\n\r\n就是这样，你的应用程序应该成功地运行并将一个新用户插入到数据库中。\r\n你可以继续这个项目，集成你需要的其他模块，并创建更多的实体。\r\n\r\n> 运行`typeorm init --name MyProject --database mysql --express`命令可以安装`express`，生成一个更高级的项目。\r\n\r\n## 分步指南\r\n\r\n你对ORM的期望是什么？\r\n首先，你预期它将为你创建数据库表，并查找/插入/更新/删除你的数据，而不必编写大量难以维护的SQL查询。\r\n本指南将向你展示如何从头开始设置TypeORM，并让它按照你所期望的ORM进行。\r\n\r\n### 创建模型\r\n\r\n与数据库一起工作从创建表开始。\r\n如何告诉TypeORM创建一个数据库表？\r\n答案是 - 通过模型。\r\n你的应用程序中的模型就是你的数据库中的表。\r\n\r\n例如你有一个 `Photo` 模型：\r\n\r\n```typescript\r\nexport class Photo {\r\n    id: number;\r\n    name: string;\r\n    description: string;\r\n    filename: string;\r\n    views: number;\r\n}\r\n```\r\n\r\n你想在你的数据库中存储照片。\r\n要在数据库中存储东西，首先需要一个数据库表，并从模型创建数据库表。\r\n不是所有的模型，而仅仅是那些你定义为*实体*。\r\n\r\n### 创建实体\r\n\r\n*实体*是你用 `@Entity` 装饰的模型。\r\n将为这些模型创建一个数据库表。\r\n使用TypeORM你将在任何地方使用实体。\r\n你可以使用他们加载/插入/更新/删除并执行其他操作。\r\n\r\n让我们把`Photo`模型变成一个实体：\r\n\r\n```typescript\r\nimport {Entity} from "typeorm";\r\n\r\n@Entity()\r\nexport class Photo {\r\n    id: number;\r\n    name: string;\r\n    description: string;\r\n    filename: string;\r\n    views: number;\r\n    isPublished: boolean;\r\n}\r\n```\r\n\r\n现在，将会为 `Photo` 实体创建一个数据库表，我们能够在应用程序的任何地方使用它。\r\n我们已经创建了一个数据库表，然而没有列的表示不存在的。\r\n让我们在数据库表中创建一些列吧。\r\n\r\n### 添加数据库表列\r\n\r\n要添加数据库列，只需要将生成的实体的属性用 `@Column` 装饰。\r\n\r\n```typescript\r\nimport {Entity, Column} from "typeorm";\r\n\r\n@Entity()\r\nexport class Photo {\r\n\r\n    @Column()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    description: string;\r\n\r\n    @Column()\r\n    filename: string;\r\n\r\n    @Column()\r\n    views: number;\r\n\r\n    @Column()\r\n    isPublished: boolean;\r\n}\r\n```\r\n\r\n现在 `id`，`name`，`description`，`filename`，`views` 和 `isPublished` 列将会被添加 `photo` 表。\r\n数据库中的列类型是从你使用的属性类型推断出来的，例如：`number` 将会被转成 `integer`，`string` 转为 `varchar`，`boolean` 转为 `bool`，等。\r\n但是你可以通过隐式在 `@Column` 装饰器传入类型将列类型指定为任何你数据库支持的类型。\r\n\r\n我们生成了一个带有列的数据库表，但是还剩下一件事。\r\n每个数据库表必须有一个带有主键的列。\r\n\r\n### 创建一个主键列\r\n\r\n每个表都**必须**至少有一个主键列。这是一个要求，你不能避免。要使列成为主键，你需要使用 `@PrimaryColumn` 修饰符。\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryColumn} from "typeorm";\r\n\r\n@Entity()\r\nexport class Photo {\r\n\r\n    @PrimaryColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    description: string;\r\n\r\n    @Column()\r\n    filename: string;\r\n\r\n    @Column()\r\n    views: number;\r\n\r\n    @Column()\r\n    isPublished: boolean;\r\n}\r\n```\r\n\r\n### 创建一个自动生成的列\r\n\r\n现在，假设你希望将id列自动生成(这就是所谓的自动递增/按顺序/连续的/生成唯一标识列)。\r\n要做到这一点，你需要将 `@PrimaryColumn` 修饰符更改为 `@PrimaryGeneratedColumn` 修饰符：\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn} from "typeorm";\r\n\r\n@Entity()\r\nexport class Photo {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    description: string;\r\n\r\n    @Column()\r\n    filename: string;\r\n\r\n    @Column()\r\n    views: number;\r\n\r\n    @Column()\r\n    isPublished: boolean;\r\n}\r\n```\r\n\r\n### 列数据类型\r\n\r\n接下来，让我们修复数据类型。默认情况下，字符串被映射到一个varchar(255)类型（取决于数据库类型）。\r\n数字被映射到一个integer类型（取决于数据库类型）。\r\n我们不希望所有的列都是有限的varchars或整数。\r\n让我们设置正确的数据类型：\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn} from "typeorm";\r\n\r\n@Entity()\r\nexport class Photo {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({\r\n        length: 100\r\n    })\r\n    name: string;\r\n\r\n    @Column("text")\r\n    description: string;\r\n\r\n    @Column()\r\n    filename: string;\r\n\r\n    @Column("double")\r\n    views: number;\r\n\r\n    @Column()\r\n    isPublished: boolean;\r\n}\r\n```\r\n\r\n列类型取决于数据库支持的类型。\r\n可以设置数据库支持的任何列类型。\r\n更多关于支持的列类型信息可以在这里找到[这里](./docs/entity.md#column-types)。\r\n\r\n### 创建数据库连接\r\n\r\n现在实体已经有了，让我们新建一个 `index.ts` （或 `app.ts` 不管你叫它什么）的文件，并配置数据库连接：\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection({\r\n    type: "mysql",\r\n    host: "localhost",\r\n    port: 3306,\r\n    username: "root",\r\n    password: "admin",\r\n    database: "test",\r\n    entities: [\r\n        Photo\r\n    ],\r\n    synchronize: true,\r\n    logging: false\r\n}).then(connection => {\r\n    // 这里可以写实体操作相关的代码 \r\n}).catch(error => console.log(error));\r\n```\r\n\r\n在例子里使用的是mysql，你也可以选择其他数据库，只需要简单修改driver选项里的数据库的类型就可以了，比如： \r\nmysql, mariadb, postgres, sqlite, mssql or oracle.\r\n同样可以修改host, port, username, password 以及database等设置.\r\n\r\n把Photo实体加到数据连接的实体列表中，所有需要在这个连接下使用的实体都必须加到这个列表中。\r\n\r\n`synchronize`选项可以在应用启动时确保你的实体和数据库保持同步。 \r\n\r\n### 引用目录下的所有实体\r\n\r\n接下来我们可能会创建更多的实体并把它们一一加到配置当中。\r\n不过这样会比较麻烦，好在可以直接写上实体的目录，这样这个目录下的所有实体都可以在当前连接中被使用：\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\n\r\ncreateConnection({\r\n    driver: {\r\n        type: "mysql",\r\n        host: "localhost",\r\n        port: 3306,\r\n        username: "root",\r\n        password: "admin",\r\n        database: "test"\r\n    },\r\n    entities: [\r\n        __dirname + "/entity/*.js"\r\n    ],\r\n    synchronize: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```\r\n\r\n### 启动应用\r\n\r\n现在可以启动`app.ts`，启动后可以发现数据库自动被初始化，并且Photo这个表也会创建出来。\r\n\r\n```shell\r\n+-------------+--------------+----------------------------+\r\n|                         photo                           |\r\n+-------------+--------------+----------------------------+\r\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\r\n| name        | varchar(500) |                            |\r\n| description | text         |                            |\r\n| filename    | varchar(255) |                            |\r\n| views       | int(11)      |                            |\r\n| isPublished | boolean      |                            |\r\n+-------------+--------------+----------------------------+\r\n```\r\n\r\n### 添加和插入photo\r\n\r\n现在创建一个新的photo然后存到数据库：\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\n\r\ncreateConnection(/*...*/).then(connection => {\r\n\r\n    let photo = new Photo();\r\n    photo.name = "Me and Bears";\r\n    photo.description = "I am near polar bears";\r\n    photo.filename = "photo-with-bears.jpg";\r\n    photo.views = 1;\r\n    photo.isPublished = true;\r\n\r\n    connection.manager\r\n            .save(photo)\r\n            .then(photo => {\r\n                console.log("Photo has been saved");\r\n            });\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n  \r\n### 使用async/await语法\r\n\r\n现在利用TypeScript的async/await语法来实现同样的功能：\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    let photo = new Photo();\r\n    photo.name = "Me and Bears";\r\n    photo.description = "I am near polar bears";\r\n    photo.filename = "photo-with-bears.jpg";\r\n    photo.views = 1;\r\n    photo.isPublished = true;\r\n\r\n    await connection.manager.save(photo);\r\n    console.log("Photo has been saved");\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n\r\n### 使用EntityManager\r\n\r\n刚刚我们创建了一个新的photo并且存进数据库。使用EntityManager可以操作实体，现在用`EntityManager`来把photo从数据库中取出来。\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    /*...*/\r\n    let savedPhotos = await connection.manager.find(Photo);\r\n    console.log("All photos from the db: ", savedPhotos);\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n\r\nsavedPhotos 会从数据库中取到的是一个Photo对象的数组\r\n\r\n### 使用Repositories\r\n\r\n现在重构下代码，使用`Repository`来代替EntityManage。每个实体都有自己的repository，可以对这个实体进行任何操作。\r\n如果要对实体做很多操作，Repositories会比EntityManager更加方便。\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    let photo = new Photo();\r\n    photo.name = "Me and Bears";\r\n    photo.description = "I am near polar bears";\r\n    photo.filename = "photo-with-bears.jpg";\r\n    photo.views = 1;\r\n    photo.isPublished = true;\r\n\r\n    let photoRepository = connection.getRepository(Photo);\r\n\r\n    await photoRepository.save(photo);\r\n    console.log("Photo has been saved");\r\n\r\n    let savedPhotos = await photoRepository.find();\r\n    console.log("All photos from the db: ", savedPhotos);\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n \r\n### 从数据库中取photos\r\n\r\n现在来尝试用Repository做一些取数据方面的操作:\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    /*...*/\r\n    let allPhotos = await photoRepository.find();\r\n    console.log("All photos from the db: ", allPhotos);\r\n\r\n    let firstPhoto = await photoRepository.findOneById(1);\r\n    console.log("First photo from the db: ", firstPhoto);\r\n\r\n    let meAndBearsPhoto = await photoRepository.findOne({ name: "Me and Bears" });\r\n    console.log("Me and Bears photo from the db: ", meAndBearsPhoto);\r\n\r\n    let allViewedPhotos = await photoRepository.find({ views: 1 });\r\n    console.log("All viewed photos: ", allViewedPhotos);\r\n\r\n    let allPublishedPhotos = await photoRepository.find({ isPublished: true });\r\n    console.log("All published photos: ", allPublishedPhotos);\r\n\r\n    let [allPhotos, photosCount] = await photoRepository.findAndCount();\r\n    console.log("All photos: ", allPublishedPhotos);\r\n    console.log("Photos count: ", allPublishedPhotos);\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n\r\n### 更新photo\r\n\r\n现在来从数据库中取出一个photo，修改并更新到数据库。\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    /*...*/\r\n    let photoToUpdate = await photoRepository.findOneById(1);\r\n    photoToUpdate.name = "Me, my friends and polar bears";\r\n    await photoRepository.save(photoToUpdate);\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n\r\n这个`id = 1`的photo在数据库中就成功更新了.\r\n\r\n### 删除photo\r\n\r\n再来，从数据库中删除我们的photo:\r\n\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    /*...*/\r\n    let photoToRemove = await photoRepository.findOneById(1);\r\n    await photoRepository.remove(photoToRemove);\r\n\r\n}).catch(error => console.log(error));\r\n``` \r\n\r\n这个`id = 1`的photo就在数据库中被移除了。\r\n\r\n### 一对一关系\r\n\r\n来创建与另一个类的一对一关系。\r\n新建PhotoMetadata.ts用来存photo的元信息。\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn} from "typeorm";\r\nimport {Photo} from "./Photo";\r\n\r\n@Entity()\r\nexport class PhotoMetadata {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column("int")\r\n    height: number;\r\n\r\n    @Column("int")\r\n    width: number;\r\n\r\n    @Column()\r\n    orientation: string;\r\n\r\n    @Column()\r\n    compressed: boolean;\r\n\r\n    @Column()\r\n    comment: string;\r\n\r\n    @OneToOne(type => Photo)\r\n    @JoinColumn()\r\n    photo: Photo;\r\n}\r\n```\r\n\r\n这里我们用到了一个新的装饰器`@OneToOne`，它可以用来在两个实体之间创建一对一关系。\r\n`type => Photo`指示了我们想要连接的实体类名，这里因为TypeScript语言的支持原因不能直接用类名。\r\n当然也可以使用`() => Photo`，但是`type => Photo`显得更有可读性。\r\nType变量本身并不包含任何东西。\r\n\r\n我们同样使用了`@JoinColumn`装饰器，这个装饰器可以指定一对一关系的拥有者。\r\n关系可以是单向的或双向的，但是只有一方是拥有者，加个这个装饰器就表示关系是给这个表服务的。\r\n\r\n现在运行app，会新创建一个table，这个table有一个连接photo的外键：\r\n\r\n```shell\r\n+-------------+--------------+----------------------------+\r\n|                      photo `译者注：应该是PhotoMetadata` |\r\n+-------------+--------------+----------------------------+\r\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\r\n| height      | int(11)      |                            |\r\n| width       | int(11)      |                            |\r\n| comment     | varchar(255) |                            |\r\n| compressed  | boolean      |                            |\r\n| orientation | varchar(255) |                            |\r\n| photo       | int(11)      | FOREIGN KEY                |\r\n+-------------+--------------+----------------------------+\r\n```\r\n\r\n### 存一个有一对一关系的对象\r\n\r\n现在来创建一个photo，一个photo的元信息，并把它们已经连接起来。\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\nimport {PhotoMetadata} from "./entity/PhotoMetadata";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    // 创建一个photo\r\n    let photo = new Photo();\r\n    photo.name = "Me and Bears";\r\n    photo.description = "I am near polar bears";\r\n    photo.filename = "photo-with-bears.jpg"\r\n    photo.isPublished = true;\r\n\r\n    // 创建一个photo的元信息\r\n    let  metadata = new PhotoMetadata();\r\n    metadata.height = 640;\r\n    metadata.width = 480;\r\n    metadata.compressed = true;\r\n    metadata.comment = "cybershoot";\r\n    metadata.orientation = "portait";\r\n    metadata.photo = photo; // 这里把两者连起来\r\n\r\n    // 获取实体repositories\r\n    let photoRepository = connection.getRepository(Photo);\r\n    let metadataRepository = connection.getRepository(PhotoMetadata);\r\n\r\n    // 先来把photo存到数据库\r\n    await photoRepository.save(photo);\r\n\r\n    // photo存完了，再存下photo的元信息\r\n    await metadataRepository.save(metadata);\r\n\r\n    // 搞定\r\n    console.log("metadata is saved, and relation between metadata and photo is created in the database too");\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n \r\n### 双向关系\r\n\r\n关系可以是单向的或是双向的. \r\n现在PhotoMetadata和Photo的关系是单向的，关系拥有者是PhotoMetadata，Photo并不知道PhotoMetadata，这样如果要想从Photo里得到PhotoMetadata的数据会比较麻烦。\r\n现在来改变一下，把单向改成双向：\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn} from "typeorm";\r\nimport {Photo} from "./Photo";\r\n\r\n@Entity()\r\nexport class PhotoMetadata {\r\n\r\n    /* ... 其他列 */\r\n\r\n    @OneToOne(type => Photo, photo => photo.metadata)\r\n    @JoinColumn()\r\n    photo: Photo;\r\n}\r\n```   \r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn, OneToOne} from "typeorm";\r\nimport {PhotoMetadata} from "./PhotoMetadata";\r\n\r\n@Entity()\r\nexport class Photo {\r\n\r\n    /* ... 其他列 */\r\n\r\n    @OneToOne(type => PhotoMetadata, photoMetadata => photoMetadata.photo)\r\n    metadata: PhotoMetadata;\r\n}\r\n```  \r\n\r\n`photo => photo.metadata` 是用来指定反向关系的字段名字，photo.metadata就指出了Photo里的metadata字段名字。\r\n当然也可以使用`@OneToOne(\'metadata\')`来达到同样的目的，不过这种对于以后的代码重构不友好。\r\n\r\n按上面说的，`@JoinColumn`只能在关系的一边使用来使这边做为关系的拥有者，关系拥有者在数据库里的表现就是拥有一个外键列。\r\n\r\n### 取出关系对象的数据\r\n\r\n现在来用一个查询来取出photo以及它的元信息。\r\n有两种方式，一是用`FindOptions`，另一个是使用`QueryBuilder`。\r\n先试下`FindOptions`，通过指定`FindOptions`接口作为参数来使用`Repository.find`方法可以完成非常复杂的查询。\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\nimport {PhotoMetadata} from "./entity/PhotoMetadata";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    /*...*/\r\n    let photoRepository = connection.getRepository(Photo);\r\n    let photos = await photoRepository.find({\r\n        alias: "photo",\r\n        innerJoinAndSelect: {\r\n            "metadata": "photo.metadata"\r\n        }\r\n    });\r\n\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n返回的photos是从数据库里取回的photo的数组，每个photo都包含它的元信息。\r\n\r\n`alias` 是FindOptions的一个必需选项，这是你自己在select里定义的别名，然后需要用在接下来的 where, order by, group by, join 以及其他表达式.\r\n\r\n这里还用到了`innerJoinAndSelect`，表示内联查询photo.metadata的数据。 \r\n`"photo.metadata"`里"photo"是一个别名，"metadata"则是你想查询的那个对象的属性名。 \r\n`"metadata"`: 是内联返回数据的新的别名.\r\n\r\n下面来尝试第二种方式：`QueryBuilder`来达到同样的目的. 使用`QueryBuilder`可以优雅完成复杂的查询:\r\n\r\n```typescript\r\nimport {createConnection} from "typeorm";\r\nimport {Photo} from "./entity/Photo";\r\nimport {PhotoMetadata} from "./entity/PhotoMetadata";\r\n\r\ncreateConnection(/*...*/).then(async connection => {\r\n\r\n    /*...*/\r\n    let photoRepository = connection.getRepository(Photo);\r\n    let photos = await photoRepository.createQueryBuilder("photo")\r\n            .innerJoinAndSelect("photo.metadata", "metadata")\r\n            .getMany();\r\n\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n\r\n### 使用 cascade 选项来自动保存关系着的对象\r\n\r\n上面要保存关系对象需要一个一个来保存，略显麻烦。\r\n如果我们需要当关系对象中的一个被保存后，另一个也同样被保存，则可以使用`cascade`选项来做到。\r\n稍微改下`@OneToOne`装饰:\r\n\r\n```typescript\r\nexport class Photo {\r\n    /// ... 其他列\r\n\r\n    @OneToOne(type => PhotoMetadata, metadata => metadata.photo, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true\r\n    })\r\n    metadata: PhotoMetadata;\r\n}\r\n```\r\n\r\n* **cascadeInsert** - 如果表中没有关系中的metadata，则自动insert，即我们不需要再手动insert一个新的photoMetadata对象。\r\n* **cascadeUpdate** - 如果metadata有变化，则自动update。\r\n* **cascadeRemove** - 如果把photo里的metadata移除了，也就是为空，则会自动remove表中的这条metadata数据。\r\n\r\n使用cascadeInsert就可以不需要像上面那边先存photo再存metadata了。\r\n现在我们来单单存photo对象，由于cascade的作用，metadata也会自动存上。\r\n\r\n```typescript\r\ncreateConnection(options).then(async connection => {\r\n\r\n    // 创建photo对象\r\n    let photo = new Photo();\r\n    photo.name = "Me and Bears";\r\n    photo.description = "I am near polar bears";\r\n    photo.filename = "photo-with-bears.jpg"\r\n    photo.isPublished = true;\r\n\r\n    // 创建photo metadata 对象\r\n    let metadata = new PhotoMetadata();\r\n    metadata.height = 640;\r\n    metadata.width = 480;\r\n    metadata.compressed = true;\r\n    metadata.comment = "cybershoot";\r\n    metadata.orientation = "portait";\r\n    \r\n    photo.metadata = metadata; // 连接起来\r\n\r\n    // 得到repository\r\n    let photoRepository = connection.getRepository(Photo);\r\n\r\n    // 存photo\r\n    await photoRepository.save(photo);\r\n    // photo metadata也自动存上了\r\n    console.log("Photo is saved, photo metadata is saved too.")\r\n\r\n}).catch(error => console.log(error));\r\n```     \r\n\r\n### 多对一/一对多关系\r\n\r\n接下来显示多对一/一对多关系。\r\n假设一个photo会有一个author，并且每个author可以有很多photo。\r\n先创建Author实体：\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn, OneToMany, JoinColumn} from "typeorm";\r\nimport {Photo} from "./Photo";\r\n\r\n@Entity()\r\nexport class Author {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Photo, photo => photo.author) // 备注：下面会为Photo创建author属性\r\n    photos: Photo[];\r\n}\r\n```\r\n\r\nAuthor包含一个反向的关系，`OneToMany`总是反向的，并且总是与`ManyToOne`成对出现。\r\n\r\n现在来为Photo加上关系拥有者。\r\n\r\n```typescript\r\nimport {Entity, Column, PrimaryGeneratedColumn, ManyToOne} from "typeorm";\r\nimport {PhotoMetadata} from "./PhotoMetadata";\r\nimport {Author} from "./Author";\r\n\r\n@Entity()\r\nexport class Photo {\r\n\r\n    /* ... 其他列 */\r\n\r\n    @ManyToOne(type => Author, author => author.photos)\r\n    author: Author;\r\n}\r\n```\r\n\r\n在`ManyToOne/OneToMany`关系中，拥有者一边总是`ManyToOne`。`译者注：拥有外键者即关系拥有者`\r\n也就是`ManyToOne`的那个字段存的是另一个对象的id。`译者注：也就是上面的author虽然属性是Author，但在数据库中类型是Author id的类型，存的也是id`\r\n\r\n执行上面的代码将会自动创建author表，如下:\r\n\r\n\r\n```shell\r\n+-------------+--------------+----------------------------+\r\n|                          author                         |\r\n+-------------+--------------+----------------------------+\r\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\r\n| name        | varchar(255) |                            |\r\n+-------------+--------------+----------------------------+\r\n```\r\n\r\n因为photo表已经存在，所以不是增加而是修改photo表 - 添加一个新外键列author:\r\n\r\n```shell\r\n+-------------+--------------+----------------------------+\r\n|                         photo                           |\r\n+-------------+--------------+----------------------------+\r\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\r\n| name        | varchar(255) |                            |\r\n| description | varchar(255) |                            |\r\n| filename    | varchar(255) |                            |\r\n| isPublished | boolean      |                            |\r\n| author      | int(11)      | FOREIGN KEY                |\r\n+-------------+--------------+----------------------------+\r\n```\r\n   \r\n### 多对多关系\r\n\r\n假设photo可以存在多个相册中，并且相册里可以包含多个photo。\r\n先创建一个`Album`类 \r\n\r\n```typescript\r\nimport {Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable} from "typeorm";\r\n\r\n@Entity()\r\nexport class Album {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @ManyToMany(type => Photo, photo => photo.albums, {  // 备注: 会在下面的Photo类里添加"albums"属性\r\n        cascadeInsert: true, // 在添加Album时，会自动添加相册里的Photo\r\n        cascadeUpdate: true, // 在更新Album时，会自动更新相册里的Photo \r\n        cascadeRemove: true  // 在移除Album时，会自动移除相册里的Photo\r\n    })\r\n    @JoinTable()\r\n    photos: Photo[];\r\n}\r\n```\r\n  \r\n`@JoinTable`多对多关系拥有者必须指定的。\r\n\r\n接着给`Photo`实体加个反向关系:\r\n\r\n```typescript\r\nexport class Photo {\r\n    /// ... 其他列\r\n\r\n    @ManyToMany(type => Album, album => album.photos, {\r\n        cascadeInsert: true, // 在添加Album时，会自动添加相册里的Photo\r\n        cascadeUpdate: true, // 在更新Album时，会自动更新相册里的Photo \r\n        cascadeRemove: true  // 在移除Album时，会自动移除相册里的Photo\r\n    })\r\n    albums: Album[];\r\n}\r\n```\r\n\r\n执行上面的代码后会自动创建一个叫 **album_photos_photo_albums**的*联接表*:\r\n\r\n```shell\r\n+-------------+--------------+----------------------------+\r\n|                album_photos_photo_albums                |\r\n+-------------+--------------+----------------------------+\r\n| album_id_1  | int(11)      | PRIMARY KEY FOREIGN KEY    |\r\n| photo_id_2  | int(11)      | PRIMARY KEY FOREIGN KEY    |\r\n+-------------+--------------+----------------------------+\r\n```\r\n\r\n记得把`Album`实体加到ConnectionOptions中:\r\n\r\n```typescript\r\nconst options: CreateConnectionOptions = {\r\n    // ... 其他配置\r\n    entities: [Photo, PhotoMetadata, Author, Album]\r\n};\r\n```\r\n\r\n现在来往数据库里插入albums和photos        \r\n\r\n```typescript\r\nlet connection = await createConnection(options);\r\n\r\n// 创建两个albums\r\nlet album1 = new Album();\r\nalbum1.name = "Bears";\r\n\r\nlet album2 = new Album();\r\nalbum2.name = "Me";\r\n\r\n// 创建两个photos\r\nlet photo1 = new Photo();\r\nphoto1.name = "Me and Bears";\r\nphoto1.description = "I am near polar bears";\r\nphoto1.filename = "photo-with-bears.jpg";\r\nphoto1.albums = [album1];\r\n\r\nlet photo2 = new Photo();\r\nphoto2.name = "Me and Bears";\r\nphoto2.description = "I am near polar bears";\r\nphoto2.filename = "photo-with-bears.jpg";\r\nphoto2.albums = [album2];\r\n\r\n// 获取Photo的repository\r\nlet photoRepository = connection.getRepository(Photo);\r\n\r\n// 依次存储photos，由于cascade，albums也同样会自动存起来\r\nawait photoRepository.save(photo1);\r\nawait photoRepository.save(photo2);\r\n\r\nconsole.log("Both photos have been saved");\r\n```\r\n\r\n### 使用QueryBuilder\r\n\r\n可以利用QueryBuilder来构建一个非常复杂的查询，例如：\r\n\r\n```typescript\r\nlet photoRepository = connection.getRepository(Photo);\r\nlet photos = await photoRepository\r\n    .createQueryBuilder("photo") // 别名，必填项，用来指定本次查询\r\n    .innerJoinAndSelect("photo.metadata", "metadata")\r\n    .leftJoinAndSelect("photo.albums", "albums")\r\n    .where("photo.isPublished=true")\r\n    .andWhere("(photo.name=:photoName OR photo.name=:bearName)")\r\n    .orderBy("photo.id", "DESC")\r\n    .skip(5)\r\n    .take(10)\r\n    .setParameters({ photoName: "My", bearName: "Mishka" })\r\n    .getMany();\r\n```\r\n\r\n这个查询会查找已经published的，并且name是"My"或"Mishka"，\r\n得到的结果会从第5个开始（分页偏移决定的），\r\n并且只会得到10个结果（分页每页个数决定的），\r\n所得结果是以id的倒序排序的，\r\nPhoto的albums是左联接，photo的metadata是内联接。\r\n\r\n你将在应用程序中大量使用QueryBuilder。\r\n了解更多QueryBuilder[这里](./docs/select-query-builder.md).\r\n\r\n## 样例\r\n\r\n看看[样例](https://github.com/typeorm/typeorm/tree/master/sample)里这些例子的用法\r\n\r\n这些仓库，你可以克隆下来帮助你开始:\r\n\r\n* [Example how to use TypeORM with TypeScript](https://github.com/typeorm/typescript-example)\r\n* [Example how to use TypeORM with JavaScript](https://github.com/typeorm/javascript-example)\r\n* [Example how to use TypeORM with JavaScript and Babel](https://github.com/typeorm/babel-example)\r\n* [Example how to use TypeORM with TypeScript and SystemJS in Browser](https://github.com/typeorm/browser-example)\r\n* [Example how to use Express and TypeORM](https://github.com/typeorm/typescript-express-example)\r\n* [Example how to use Koa and TypeORM](https://github.com/typeorm/typescript-koa-example)\r\n* [Example how to use TypeORM with MongoDB](https://github.com/typeorm/typeorm-typescript-mongo-example)\r\n* [Example how to use TypeORM in a Cordova/PhoneGap app](https://github.com/typeorm/cordova-example)\r\n* [Example how to use TypeORM with an Ionic app](https://github.com/typeorm/ionic-example)\r\n\r\n## 扩展\r\n\r\n这几个扩展可以简化TypeORM的使用，并将其与其他模块集成：\r\n\r\n* [TypeORM integration](https://github.com/typeorm/typeorm-typedi-extensions) with [TypeDI](https://github.com/pleerock/typedi)\r\n* [TypeORM integration](https://github.com/typeorm/typeorm-routing-controllers-extensions) with [routing-controllers](https://github.com/pleerock/routing-controllers)\r\n* Models generation from existing database - [typeorm-model-generator](https://github.com/Kononnable/typeorm-model-generator)',title:"TypeORM - 最好的Node.js ORM框架",last_reply_at:"2018-04-03T02:23:56.050Z",good:!1,top:!1,reply_count:13,visit_count:565,create_at:"2018-04-01",author:{loginname:"huanz",avatar_url:"https://avatars1.githubusercontent.com/u/5865669?v=4&s=120"}},{id:"5ac2e48c0ab0448f0fe3f81e",author_id:"4efc278525fa69ac69000141",tab:"share",content:"活动链接: http://react-china.org/t/topic/19934/4\r\n活动时间: 大概持续一天多, 到周三晚上\r\n规则: 有什么问题想跟工业聚提问啊, 特别是 React, 欢迎来互动~",title:"React 中文论坛, 工业聚的 AMA, 欢迎参加",last_reply_at:"2018-04-03T02:18:52.633Z",good:!1,top:!1,reply_count:0,visit_count:40,create_at:"2018-04-03",author:{loginname:"jiyinyiyong",avatar_url:"https://avatars0.githubusercontent.com/u/449224?v=4&s=120"}},{id:"5ac2282296f344940fbbac7f",author_id:"5a6ebfaa9288dc8153288322",tab:"share",content:"- 文件流导出excel\r\n> 重点：Content-Disposition 文件名要中文显示\r\n参考[https://blog.csdn.net/liuyaqi1993/article/details/78275396][1]\r\n\r\n```javascript\r\nconst nodeExcel = require('node-xlsx');\r\nconst urlencode = require('urlencode');\r\n\r\nfunction exportList(ctx, config, listData, excelName) {\r\n    let excelConfig = [];\r\n    excelConfig.push(config.map(item => {\r\n      return item.title\r\n    }))\r\n\r\n    listData.forEach(list => {\r\n      excelConfig.push(config.map(item => {\r\n        const value = list[item.name];\r\n        // 不一定要有value， 因为可能是自由组合的value\r\n        return item.format && item.format(value, list) || value;\r\n      }))\r\n    })\r\n\r\n    let buffer = nodeExcel.build([{name: excelName, data: excelConfig}]);\r\n    ctx.set('Content-Type', 'application/octet-stream');\r\n     // ctx.request.headers['user-agent']\r\n    let name = urlencode(excelName + '_' + (+new Date()) + '.xlsx', \"utf-8\");\r\n    ctx.set(\"Content-Disposition\", \"attachment; filename* = UTF-8''\"+name);    \r\n    // ctx.set(\"Content-Disposition\", \"attachment; filename=\"+ (+new Date()) + '.xlsx');\r\n    ctx.body = buffer;\r\n}\r\n\r\nmodule.exports = {\r\n  exportList: exportList\r\n}\r\n```\r\n\r\n```javascript\r\n// config 格式\r\nconst config = [{\r\n      name: 'userid',\r\n      title: '用户ID',\r\n    },{\r\n      name: 'up_time',\r\n      title: '状态时间',\r\n      format: function(value) {\r\n        return value.replace(/\\.\\d+/, '');\r\n      }\r\n    },{\r\n      name: 'appl_status_byhand',\r\n      // name: 'appl_status_byhand_desc',\r\n      title: '人审状态',\r\n      format: function(value) {\r\n        return value && manualStatus[value] &&  manualStatus[value].text || '-'\r\n      }\r\n    },{\r\n      name: 'available_quota/credit_quota',\r\n      title: '剩余额度/授信额度',\r\n      format: function(value, item) {\r\n        return `¥${item.available_quota/100 || 0}/¥${item.credit_quota/100 || 0}`\r\n      }\r\n    },{\r\n      name: 'user_type_desc',\r\n      title: '名单类型',\r\n      format: function(value, item) {\r\n        if(item.user_type) {\r\n          item.user_type.forEach(user => {\r\n            userTypeText.push(user_type_define[user] || '-');\r\n          });\r\n          return userTypeText.join('|');\r\n        } else {\r\n          return '';\r\n        }\r\n      }\r\n    }]\r\n```\r\n\r\n [1]: https://blog.csdn.net/liuyaqi1993/article/details/78275396",title:"文件流导出excel且显示中文文件名",last_reply_at:"2018-04-03T02:18:10.619Z",good:!1,top:!1,reply_count:3,visit_count:118,create_at:"2018-04-02",author:{loginname:"dmodaii",avatar_url:"https://avatars1.githubusercontent.com/u/16190100?v=4&s=120"}},{id:"5ac2e4090ab0448f0fe3f81d",author_id:"591d587bd371b6372a8afb3f",tab:"ask",content:"有人知道@types这个包吗，经常看到有引用到这里的包，而且我用的本地ＮＰＭ服务器还经常代理不了这些包，很头痛，这是个什么东东啊．",title:"npm包＠types",last_reply_at:"2018-04-03T02:16:41.700Z",good:!1,top:!1,reply_count:0,visit_count:41,create_at:"2018-04-03",author:{loginname:"ugrg",avatar_url:"https://avatars2.githubusercontent.com/u/38195?v=4&s=120"}},{id:"5ab3c02b28441024b73f5c28",author_id:"5a73b540ce45d440451465fe",tab:"ask",content:"flarum升级实在是太缓慢，但确实漂亮的一塌糊涂，超赞。\r\n我个人认为flarum的后端用php是一个败笔，php和flarum的优雅似乎完全不沾边。\r\n所以如果仅仅考虑一个论坛本身的功能的话，干脆把cnode的前端页面改成flarum风格，会不会更受欢迎？\r\n以上是臆想，如有不合适请指正。",title:"有没有可能把cnode的前端页面仿成flarum那种？",last_reply_at:"2018-04-03T01:45:36.101Z",good:!1,top:!1,reply_count:11,visit_count:587,create_at:"2018-03-22",author:{loginname:"YuanChenmang",avatar_url:"https://avatars2.githubusercontent.com/u/23253929?v=4&s=120"}},{id:"5ac2085c0ab0448f0fe3f7f0",author_id:"596a2b5edb0b6aec18a28569",tab:"share",content:"#### **起因**\r\n最近在Cnode社区看到社区大佬们重构代码用了新的技术栈，现正在公测阶段。因为正好擅长用Node.JS来开发自动化测试。为了对社区做点贡献，拉了几个技术好友，计划利用周末时间帮社区写些UI自动化代码。这一建议得到了CNodeJS的狼叔的大力支持，这一建议的帖子置顶后，又有好多热心的朋友加入了进来，有擅长自动化开发的、也有擅长手动测试的同学。  \r\n\r\n#### **计划**\r\n- **时间**：准备星期日(03-25)用一天时间进行。\r\n- **地点**：四川北路乍浦路的一间创业工坊\r\n- **目标**：基于Node.js开发CNode社区的UI自动化测试代码。\r\n- **使用技术**：当然要用Node.JS. 主要用Nodejs + [Cucumber](https://github.com/cucumber/cucumber-js) + Selenium\r\n- **开发环境**：Windows 系统使用 [CukeTest](http://cuketest.com/) 进行开发。Mac 系统使用 VSCode 进行开发\r\n\r\n迫不急待的小朋友可以先来看一下成果，经过一整天的努力，CNodeJS的各项主要界面测试都实现了，不光有代码，而且有自然语言描述的测试用例，确保所有人都能看得懂：\r\n![post_topic.gif](//dn-cnode.qbox.me/Ft8epShi4qfNLoes7jAe9nfYK20q)\r\n\r\n所有自动化测试的代码和测试用例都放在github上，网址在：\r\n[https://github.com/CnodejsTest/UIAutoTest](https://github.com/CnodejsTest/UIAutoTest)\r\n\r\n感兴趣的只要拉下来，按照描述的步骤就可以运行了。  \r\n\r\n#### **星期日**\r\n是我们自动化测试的开发日。上午10点乍浦路480号，同学们都到齐了。有一些手工测试的同学，一些自动化测试的同学。按照计划本次参与活动的同学有8名小伙伴公司做手工测试，4名小伙伴做自动化测试。他们当中有些知道行为驱动测试，有些还不知道这些概念。\r\n\r\n为了让大家能够很快的融入到一起敏捷开发，2名手工测试小伙伴与1名自动化测试小伙伴1组，手工测试的小伙伴写测试用例，自动化测试小伙伴写UI自动化脚本。位置安排是自动化测试小伙伴坐在中，手工测试小伙伴坐在两边，这样更易于他们沟通和学习。\r\n![QQ图片20180402180809.jpg](//dn-cnode.qbox.me/Fp7V6REPuxpmKBwTFtIJBDTqYYSr)\r\n\r\n##### **上午**\r\n上午主要是“统一思想，提高认识”，为了让所有人都了解开发的技术和方法。我们主要使用CukeTest客户端来阐释下行为驱动测试的概念。我们拿CNodeJS社区的“登录”场景为例，作为所有人的热身练习。  \r\n\r\n开发的过程如下：先在CukeTest上写测试用例。用例也写的差不多的时候可以在CukeTest中一键生成自动化代码框架。然后实现这个框架。边填充代码，边在页面上定位元素。将元素定位的信息填充到代码中。我们知道，Selenium定位信息可以选ID, CSS, XPath等。当实现完这个测试用例就可点击运行。经过验证能够正常登陆。\r\n\r\n有些手动功能测试的小朋友从来没做过自动化测试的开发，但跟着自动化测试老司机们，也没过多久就写出来了。而且能够成功运行，登陆到测试的环境搭建的CNodeJS社区。有些不由的感叹自动化测试也可以这么简单。效果如下：\r\n![login.gif](//dn-cnode.qbox.me/FlUtA119-DW2fEUrmFOisNWQU93J)\r\n\r\n当这个场景完成后，通过CukeTest一键转换成“场景”大纲就可添加更多的测试数据了。\r\n不光有正确的用户名和密码登录，而且可以验证错误用户名和密码登录。这样一个测试场景就变成了n个:\r\n![无标题.png](//dn-cnode.qbox.me/FhAfo8rm5CAGoHsFjm7_F90mlN-e)\r\n上午主要就是开发登陆场景。由于大家都是临时过来，刚开始还是不是很熟练，经过几轮的协作，大家慢慢熟悉了开发流程。  \r\n\r\n##### **下午**\r\n中午吃过饭，为提高效率，自动化测试小伙伴就单独出来去写UI自动化代码。功能测试小伙伴去学习一些基本的selenium-webdriver 知识，他们通过使用CukeTest生成的自动化代码，模仿之前的代码能够很快速的实现一个功能，大家都很开心。\r\n![QQ图片20180402180816.jpg](//dn-cnode.qbox.me/Fi67rWYhceKoLxeh4d1ZXgErEDkh)\r\n自动化同学相继开发出来测试脚本，所以晚些时候，主要调试自动化同学开发的脚本，并且对场景进行添加校验点。最终，我们实现了社区的用户注册，用户登录，发布话题，删除话题，收藏话题，回复话题的UI自动化。修改完成的脚本上传到GitHub代码库。  \r\n\r\n**总结：**\r\n通过这次沙龙，大家在一起协调的也非常好，大家也一起增长了测试经验，同时，也认识了新的朋友。更重要是，我们的自动化代码将会贡献给Cnode社区，造福大家。这里要感谢Cnode社区，提供一个这样的平台，并且鼓励我们。\r\n同时感谢CukeTest，提供工具能让我们很快的协助开发。也感谢猫叔，给我们提供场地，让我们能够坐在一起交流。\r\n![QQ图片20180402180822.jpg](//dn-cnode.qbox.me/Fv1tEGdM2ypy9hIkJwtKTWyDw7w_)",title:"Node.JS自动化测试在CNode社区中的应用  -- CnodeJS线下沙龙活动",last_reply_at:"2018-04-03T01:19:25.463Z",good:!0,top:!1,reply_count:12,visit_count:300,create_at:"2018-04-02",author:{loginname:"imzengyang",avatar_url:"https://avatars1.githubusercontent.com/u/22312483?v=4&s=120"}}],tab:"",loading:!1,pageInfo:{page:1,total:1e3}},user:{loginInfo:{},userInfo:{},messages:{has_read_messages:[],hasnot_read_messages:[]},accesstoken:"",loading:!1}},serverRendered:!0}</script><script defer src="/nuxt-blog/_nuxt/manifest.99e36d02ae9d35f9a67a.js"></script><script defer src="/nuxt-blog/_nuxt/layouts_default.3e9b7a2d9551da30542e.js"></script><script defer src="/nuxt-blog/_nuxt/pages_index.1a1dabc786aba819b9a7.js"></script><script defer src="/nuxt-blog/_nuxt/vendor.99e36d02ae9d.js"></script><script defer src="/nuxt-blog/_nuxt/hare.3ad678fdff0b.js"></script>
  

